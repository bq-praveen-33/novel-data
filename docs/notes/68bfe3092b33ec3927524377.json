{
  "online_content": {
    "type": "doc",
    "content": [
      {
        "type": "codeBlock",
        "attrs": {
          "language": "typescriptreact"
        },
        "content": [
          {
            "type": "text",
            "text": "\"use client\";\nimport { NoAccessMessage } from \"@/components/ui/no-access\";\nimport { useShare } from \"@/contexts/ShareContext\";\nimport { useAuth } from \"@/hooks/use-auth\";\nimport { useNotes } from \"@/hooks/use-notes\";\nimport { checkUserWriteAccess, isOwner } from \"@/services-frontend/user/userServices\";\nimport { approveNote, inviteToNote, publishNote } from \"@/services-frontend/note/notesService\";\n// Declare the global variable for TypeScript\ndeclare global {\n  interface Window {\n    __aiPromptContent?: string;\n  }\n}\n// import { useSyncQueue } from \"@/hooks/use-syncQueue\";\nimport { usePromptForPageTitle } from \"@/hooks/use-promptForPageTitle\";\nimport useNoteActions from \"@/hooks/use-updateNode\";\nimport { useCollaborativeEditor } from \"@/hooks/useCollaborativeEditor\";\nimport { getWithAuth, postWithAuth } from \"@/lib/api-helpers\";\nimport type { publishState } from \"@/lib/api-helpers\";\nimport { defaultEditorContent } from \"@/lib/content\";\nimport { useQueryClient } from \"@tanstack/react-query\";\nimport {\n  EditorCommand,\n  EditorCommandEmpty,\n  EditorCommandItem,\n  EditorCommandList,\n  EditorContent,\n  EditorRoot,\n  ImageResizer,\n  type JSONContent,\n  handleCommandNavigation,\n  handleImageDrop,\n  handleImagePaste,\n} from \"novel\";\nimport { useEffect, useMemo, useRef, useState } from \"react\";\nimport { toast } from \"sonner\";\nimport { useDebouncedCallback } from \"use-debounce\";\nimport { ErrorPage } from \"./ErrorPage\";\nimport { NotFoundPage } from \"./NotFoundPage\";\nimport { defaultExtensions } from \"./extensions\";\nimport { uploadFn } from \"./image-upload\";\nimport { getSlashCommand, getSuggestionItems } from \"./slash-command\";\nimport { createMentionExtension } from \"./mention-command\";\n\nimport { useNoteContext } from \"@/contexts/NoteContext\";\nimport { useRouter } from \"next/navigation\";\nimport GenerativeMenuSwitch from \"./generative/generative-menu-switch\";\nimport { ColorSelector } from \"./selectors/color-selector\";\nimport { LinkSelector } from \"./selectors/link-selector\";\nimport { MathSelector } from \"./selectors/math-selector\";\nimport { NodeSelector } from \"./selectors/node-selector\";\nimport { TableToolbar } from \"./selectors/table-toolbar\";\nimport { TextButtons } from \"./selectors/text-buttons\";\n\nimport type { Editor } from \"@tiptap/core\";\n\n// At the top of your component file\nimport type { AdvancedEditorProps, ApiError, Invite, NoteResponse, PendingTitle } from \"@/types/advance-editor\";\nimport { OpenAI } from \"openai\";\nimport { AISelector } from \"./generative/ai-selector\";\nimport { Separator } from \"./ui/separator\";\nimport { useNotifications } from \"@/hooks/use-notifications\";\nimport { isEditorContentEmpty, isPublishResponse } from \"@/services-frontend/editor/editorService\";\nimport EditorHeader from \"./editor/editorHeader\";\nimport EditorLoading from \"./editor/editorLoading\";\n\n\n\nconst hljs = require(\"highlight.js\");\n\n\nconst TailwindNewEditor = ({ editorKey, shareNoteId, onShareComplete }: AdvancedEditorProps) => {\n  const [initialContent, setInitialContent] = useState<JSONContent | undefined>(undefined);\n  const [saveStatus, setSaveStatus] = useState<\"Saving...\" | \"Saved\" | \"Save Failed\" | \"Saved Online\" | \"Unsaved\">(\n    \"Saved\",\n  );\n\n  const [openNode, setOpenNode] = useState<boolean>(false);\n  const [openColor, setOpenColor] = useState<boolean>(false);\n  const [openLink, setOpenLink] = useState<boolean>(false);\n  const [openAI, setOpenAI] = useState<boolean>(false);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [accessError, setAccessError] = useState<ApiError | null>(null);\n  const [notFoundError, setNotFoundError] = useState<{\n    noteId: string;\n    message: string;\n  } | null>(null);\n  const [genericError, setGenericError] = useState<{\n    status: number;\n    message: string;\n    noteId?: string;\n  } | null>(null);\n\n  // Track handled errors to prevent infinite loops\n  const handledErrorRef = useRef<string | null>(null);\n  const [showModal, setShowModal] = useState<boolean>(false);\n  const [invites, setInvites] = useState<Invite[]>([{ email: \"\", permission: \"read\" }]);\n  const [readOnly, setReadOnly] = useState<boolean>(false);\n\n  const { setShareNoteId, removeSharedPage } = useShare();\n  const [publishLoading, setPublishLoading] = useState<boolean>(false);\n  const [approvalLoading, setApprovalLoading] = useState<boolean>(false);\n  const [approvalDirection, setApprovalDirection] = useState<\"approve\" | \"reject\" | null>(null);\n  const [approvalStatus, setApprovalStatus] = useState<string>(\"\");\n  const [githubRawUrl, setGithubRawUrl] = useState<string>(\"\");\n  const [publishStatus, setPublishStatus] = useState<publishState>();\n  const [isPublish, setIsPublish] = useState<boolean>();\n  const [noteOwnerMail, setNoteOwnerMail] = useState<string>(\"\");\n  const [noteOwnerUserId, setNoteOwnerUserId] = useState<string>(\"\");\n  // const [editorTitle, setEditorTitle] = useState<string>(\"Untitled\");\n  const [titleIcon, setTitleIcon] = useState<string>(\"\");\n  const [parentId, setParentId] = useState<string | null>(null);\n\n  const prevContentRef = useRef<any>(null);\n  const prevEditorKey = useRef(editorKey);\n  const [isPublicNote, setIsPublicNote] = useState<boolean>(false);\n  const [noteType, setNoteType] = useState<string>(\"original\");\n  const [ rootNodes , setRootNodes ] = useState<Node[]>([]);\n\n  // Auth hook\n  const { user } = useAuth();\n\n  // React Query hooks\n  const queryClient = useQueryClient();\n  const { getNote, updateNote: updateNoteWithQuery } = useNotes();\n\n  // Use React Query to fetch note data\n  const {\n    data: noteQueryData,\n    isError: isNoteError,\n    error: noteError,\n    isLoading: isNoteLoading,\n    refetch: refetchNote,\n  } = getNote(\n    editorKey,\n    true, // includeContent\n    \"\", // commitSha\n    \"\", // commitPath\n  );\n\n  const { promptForPageTitle, modal } = usePromptForPageTitle();\n  const {\n    notes,\n    updateNote,\n    activeTitle,\n    activeEmoji,\n    selectedNoteId,\n    setIsContentSynced,\n    isDirtyRef,\n    setNotes,\n    updateNodeInCache,\n    isTitleDirtyRef,\n    setSocketConnected,\n    editorTitle,\n    setEditorTitle,\n    isPremiumUser,\n    childrenNotes,\n    setChildrenNotes,\n    setDocumentTitle,\n    setSharedWith,\n    setIsCurrentNoitePublic,\n  } = useNoteContext();\n  const [editing, setEditing] = useState(false);\n  const inputRef = useRef<HTMLDivElement | null>(null);\n\n  const [editorInstance, setEditorInstance] = useState<Editor | null>(null);\n  const [isRestrictedPage, setIsRestrictedPage] = useState<boolean | undefined>(undefined);\n  const [isLeader, setIsLeader] = useState(false);\n  const isLeaderRef = useRef(isLeader);\n  const [isSharedNote, setIsSharedNote] = useState<boolean>(false);\n  const pendingTitleMap = useRef<Record<string, string>>({});\n  const [pendingTitle, setPendingTitle] = useState<string>(\"\");\n  const [aiSelectorOpen, setAISelectorOpen] = useState(false);\n  const [aiSelectorPosition, setAISelectorPosition] = useState<{ left: number; top: number } | null>(null);\n  const [isSlashCommandAIOpen, setIsSlashCommandAIOpen] = useState<boolean>(false);\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const editorRef = useRef<any | null>(null); // Store editor instance - any needed for Novel editor API\n  const router = useRouter();\n\n  const { socketConnected , initialSyncDone} = useCollaborativeEditor({ \n    editor: editorRef.current,\n    editorKey,\n    mode: isPublicNote ? true : false || isSharedNote,\n    onSetLeader: setIsLeader,\n    isRestrictedPage: isRestrictedPage as boolean,\n    noteType,\n  });\nconst { mentionUser } = useNotifications();\n\n  useEffect(() => {\n    setSocketConnected(socketConnected);\n    if (socketConnected) {\n      console.log(\"In the conntection Established\");\n    }\n    if (!socketConnected) {\n      // Optionally, set a flag to disable real-time features, but DO NOT reset content.\n    }\n  }, [socketConnected]);\n\n  useEffect(()=>{\n    if(initialSyncDone){\n      setIsLoading(false)\n\n      if(noteType == \"original\"){\n        setTimeout(() => {\n          isDirtyRef.current = false;\n          const json = editorRef?.current?.getJSON();\n          prevContentRef.current = json;\n        }, 500);       \n      }\n    };\n  },[initialSyncDone]);\n\n  // Add event listener to handle AI content insertion from chat\n  useEffect(() => {\n    // Handler function for the custom event\n    const handleAIContentInsertion = (event: CustomEvent) => {\n      if (!editorRef.current) return;\n\n      const content = event.detail?.content;\n      if (!content) return;\n\n      try {\n        // Get the editor instance\n        const editor = editorRef.current;\n\n        // Move to the end of the document and focus\n        // First ensure we're at the end of the document\n        const endPosition = editor.state.doc.content.size;\n        editor.chain().focus().setTextSelection(endPosition).run();\n\n        // Trigger the AI selector at the current position\n        // Open AI selector at the end of the document\n        openAISelectorAtSelection();\n\n        // Log that we've triggered the selector\n\n        // We need to set a longer timeout to ensure the AI selector is fully open before we try to input content\n        setTimeout(() => {\n          // Try to find the CommandInput element - try multiple selectors based on the exact HTML structure\n          const inputElement = document.querySelector(\n            \"[cmdk-input], input[placeholder*='Ask AI'], input.flex.h-11.w-full.rounded-md.bg-transparent\",\n          );\n\n          if (inputElement instanceof HTMLInputElement) {\n            // Set the value\n            inputElement.value = content;\n\n            // Focus the input element\n            inputElement.focus();\n\n            // Dispatch input event to trigger the AI completion logic\n            const inputEvent = new Event(\"input\", { bubbles: true });\n            inputElement.dispatchEvent(inputEvent);\n\n            // This is critical - we need to trigger the onValueChange handler in the CommandInput component\n            // Create a custom event that will be picked up by React's synthetic event system\n            const reactChangeEvent = new Event(\"change\", { bubbles: true });\n            Object.defineProperty(reactChangeEvent, \"target\", { value: inputElement });\n            inputElement.dispatchEvent(reactChangeEvent);\n\n            // Find and click the submit button with a longer delay\n            setTimeout(() => {\n              // Try multiple selector patterns to find the button based on the exact HTML structure\n              // Target the button that's next to the input with the specific classes from the HTML\n              let submitButton = document.querySelector(\n                \"button.absolute.right-2.top-1\\\\/2.h-6.w-6.-translate-y-1\\\\/2.rounded-full.bg-\\\\[\\\\#5E7CE2\\\\], \" +\n                  \"button.rounded-full.bg-\\\\[\\\\#5E7CE2\\\\], \" +\n                  \".absolute.right-2.top-1\\\\/2 button, \" +\n                  \"[cmdk-input-wrapper] + button, \" +\n                  \"div.relative > button\",\n              );\n\n              // If that doesn't work, try to find the button by looking for the ArrowUp icon\n              if (!submitButton) {\n                const allButtons = document.querySelectorAll(\"button\");\n                for (const btn of allButtons) {\n                  if (btn.querySelector(\"svg.lucide-arrow-up\")) {\n                    submitButton = btn;\n\n                    break;\n                  }\n                }\n              }\n\n              if (submitButton && submitButton instanceof HTMLButtonElement) {\n                // Before clicking the button, let's create a global variable to store the prompt\n                // This will be used by the AI selector component\n                window.__aiPromptContent = content;\n\n                // Add a custom attribute to the button to identify it as having our prompt\n                submitButton.setAttribute(\"data-ai-prompt\", content);\n\n                // Now click the button\n                submitButton.click();\n                toast.success(\"AI prompt submitted\");\n              } else {\n                // Try to find any button inside the AI selector by targeting the exact structure from the HTML\n                const anyButton = document.querySelector(\n                  \"div.relative > button.absolute.right-2, div.relative > button\",\n                );\n                if (anyButton && anyButton instanceof HTMLButtonElement) {\n                  // Set global variable and attribute\n                  window.__aiPromptContent = content;\n                  anyButton.setAttribute(\"data-ai-prompt\", content);\n\n                  anyButton.click();\n                  toast.success(\"AI prompt submitted via alternative button\");\n                  return;\n                }\n\n                // Try to find the AI selector component based on the exact HTML structure\n                const aiSelector = document.querySelector(\n                  \"div.relative, div:has([cmdk-input]), div:has(input[placeholder*='Ask AI'])\",\n                );\n                if (aiSelector) {\n                  const buttons = aiSelector.querySelectorAll(\"button\");\n\n                  // Find the button with ArrowUp icon or similar\n                  for (const btn of buttons) {\n                    // Look for the button with the specific structure from the HTML\n                    if (\n                      btn.querySelector(\"svg.lucide-arrow-up\") ||\n                      btn.classList.contains(\"rounded-full\") ||\n                      btn.classList.contains(\"absolute\") ||\n                      btn.classList.contains(\"right-2\")\n                    ) {\n                      btn.click();\n                      toast.success(\"AI prompt submitted via icon button\");\n                      return;\n                    }\n                  }\n                }\n\n                // Try direct DOM manipulation as a last resort\n                // Try to get all buttons in the document and find one with arrow-up icon\n                const allButtons = document.querySelectorAll(\"button\");\n\n                // Look for a button with arrow-up SVG\n                let foundButton = false;\n                allButtons.forEach((btn, i) => {\n                  const btnHTML = btn.innerHTML;\n                  if (\n                    btnHTML.includes(\"arrow-up\") ||\n                    btnHTML.includes(\"lucide-arrow-up\") ||\n                    btn.classList.contains(\"rounded-full\")\n                  ) {\n                    btn.click();\n                    foundButton = true;\n                    toast.success(\"AI prompt submitted via found button\");\n                    return;\n                  }\n                });\n\n                // Try to find the button by its position relative to the AI input\n                if (!foundButton) {\n                  const inputParent = inputElement.closest(\".relative\");\n                  if (inputParent) {\n                    const nearbyButton = inputParent.querySelector(\"button\");\n                    if (nearbyButton) {\n                      nearbyButton.click();\n                      foundButton = true;\n                      toast.success(\"AI prompt submitted via nearby button\");\n                      return;\n                    }\n                  }\n                }\n\n                // If still no button found, try Enter key\n                if (!foundButton) {\n                  // Try to trigger the handleAIComplete function by simulating an Enter key press\n                  const enterEvent = new KeyboardEvent(\"keydown\", {\n                    key: \"Enter\",\n                    code: \"Enter\",\n                    keyCode: 13,\n                    which: 13,\n                    bubbles: true,\n                    cancelable: true,\n                  });\n                  inputElement.dispatchEvent(enterEvent);\n\n                  // Also try to trigger a form submission as a fallback\n                  setTimeout(() => {\n                    const form = inputElement.closest(\"form\");\n                    if (form) {\n                      const submitEvent = new Event(\"submit\", { bubbles: true, cancelable: true });\n                      form.dispatchEvent(submitEvent);\n                    }\n                  }, 100);\n\n                  toast.success(\"AI prompt submitted via Enter key\");\n                }\n              }\n            }, 300); // Longer delay to ensure button is ready\n          } else {\n            toast.error(\"Couldn't find AI input field\");\n          }\n        }, 500); // Increased timeout to ensure selector is fully open\n\n        // We don't show success immediately as the actual content generation will happen asynchronously\n      } catch (error) {\n        console.error(\"Error triggering AI content generation:\", error);\n        toast.error(\"Failed to trigger AI content generation\");\n      }\n    };\n\n    // Add event listener\n    window.addEventListener(\"insert-ai-content\", handleAIContentInsertion as EventListener);\n\n    // Also check URL for ai_content parameter when loading\n    const checkURLForContent = () => {\n      try {\n        const urlParams = new URLSearchParams(window.location.search);\n        const aiContent = urlParams.get(\"ai_content\");\n\n        if (aiContent && editorRef.current) {\n          // Remove the parameter from URL without refreshing\n          window.history.replaceState({}, document.title, window.location.pathname);\n\n          // Wait a bit for the editor to fully initialize\n          setTimeout(() => {\n            // Move to the end of the document and focus\n            editorRef.current?.chain().focus().selectTextblockEnd().run();\n\n            // Open the AI selector and trigger the prompt\n            openAISelectorAtSelection();\n\n            // Set the decoded content in the input field after a longer delay\n            setTimeout(() => {\n              const inputElement = document.querySelector(\"[cmdk-input]\");\n              if (inputElement instanceof HTMLInputElement) {\n                console.log(\"URL param: Found input element, setting value:\", aiContent);\n\n                // Set the value\n                inputElement.value = decodeURIComponent(aiContent);\n\n                // Focus the input element\n                inputElement.focus();\n\n                // Dispatch input event to trigger the AI completion logic\n                const inputEvent = new Event(\"input\", { bubbles: true });\n                inputElement.dispatchEvent(inputEvent);\n\n                console.log(\"URL param: Input event dispatched\");\n\n                // Find and click the submit button with a longer delay\n                setTimeout(() => {\n                  console.log(\"URL param: Looking for submit button\");\n                  // Try multiple selector patterns to find the button based on the exact HTML structure\n                  // Target the button that's next to the input with the specific classes from the HTML\n                  const submitButton = document.querySelector(\n                    \"button.absolute.right-2.top-1\\\\/2.h-6.w-6.-translate-y-1\\\\/2.rounded-full.bg-\\\\[\\\\#5E7CE2\\\\], \" +\n                      \"button.rounded-full.bg-\\\\[\\\\#5E7CE2\\\\], \" +\n                      \".absolute.right-2.top-1\\\\/2 button, \" +\n                      \"[cmdk-input-wrapper] + button, \" +\n                      \"div.relative > button\",\n                  );\n\n                  if (submitButton && submitButton instanceof HTMLButtonElement) {\n                    console.log(\"URL param: Found submit button, clicking\");\n                    submitButton.click();\n                    toast.success(\"AI prompt submitted\");\n                  } else {\n                    console.log(\"URL param: Submit button not found, trying alternative approaches\");\n\n                    // Try to find any button inside the AI selector by targeting the exact structure from the HTML\n                    const anyButton = document.querySelector(\n                      \"div.relative > button.absolute.right-2, div.relative > button\",\n                    );\n                    if (anyButton && anyButton instanceof HTMLButtonElement) {\n                      console.log(\"URL param: Found alternative button, clicking\");\n                      anyButton.click();\n                      toast.success(\"AI prompt submitted via alternative button\");\n                      return;\n                    }\n\n                    // Try to find the AI selector component based on the exact HTML structure\n                    const aiSelector = document.querySelector(\n                      \"div.relative, div:has([cmdk-input]), div:has(input[placeholder*='Ask AI'])\",\n                    );\n                    if (aiSelector) {\n                      console.log(\"URL param: Found AI selector container, looking for button inside\");\n                      const buttons = aiSelector.querySelectorAll(\"button\");\n                      console.log(`URL param: Found ${buttons.length} buttons in AI selector`);\n\n                      // Find the button with ArrowUp icon or similar\n                      for (const btn of buttons) {\n                        // Look for the button with the specific structure from the HTML\n                        if (\n                          btn.querySelector(\"svg.lucide-arrow-up\") ||\n                          btn.classList.contains(\"rounded-full\") ||\n                          btn.classList.contains(\"absolute\") ||\n                          btn.classList.contains(\"right-2\")\n                        ) {\n                          console.log(\"URL param: Found button with icon, clicking\");\n                          btn.click();\n                          toast.success(\"AI prompt submitted via icon button\");\n                          return;\n                        }\n                      }\n                    }\n\n                    // Last resort: Simulate pressing Enter key\n                    console.log(\"URL param: No buttons found, trying Enter key simulation\");\n                    const enterEvent = new KeyboardEvent(\"keydown\", {\n                      key: \"Enter\",\n                      code: \"Enter\",\n                      keyCode: 13,\n                      which: 13,\n                      bubbles: true,\n                      cancelable: true,\n                    });\n                    inputElement.dispatchEvent(enterEvent);\n                    toast.success(\"AI prompt submitted via Enter key\");\n                  }\n                }, 300); // Longer delay to ensure button is ready\n              } else {\n                console.error(\"URL param: AI input field not found\");\n              }\n            }, 500);\n          }, 500);\n        }\n      } catch (error) {\n        console.error(\"Error processing AI content from URL:\", error);\n      }\n    };\n\n    // Check once after the editor is loaded\n    if (editorRef.current) {\n      checkURLForContent();\n    }\n\n    // Clean up\n    return () => {\n      window.removeEventListener(\"insert-ai-content\", handleAIContentInsertion as EventListener);\n    };\n  }, [editorRef.current]);\n\n  const handlePageCreated = (href: string) => {\n    router.push(href); \n  };\n\n  function openAISelectorAtSelection() {\n    if (editorRef.current) {\n      setOpenAI(false);\n\n      const selection = editorRef.current.view.state.selection;\n      const coords = editorRef.current.view.coordsAtPos(selection.from);\n\n      const editorContainer = editorRef.current.options.element;\n      const editorRect = editorContainer.getBoundingClientRect();\n\n      let left = coords.left - editorRect.left + 10;\n      const top = coords.bottom - editorRect.top + 200;\n\n      const aiSelectorWidth = 400;\n      const maxLeft = Math.min(editorRect.width, window.innerWidth) - aiSelectorWidth - 20;\n      if (left > maxLeft) {\n        left = maxLeft;\n      }\n      if (left < 10) {\n        left = 10;\n      }\n\n      setAISelectorPosition({ left, top });\n      setAISelectorOpen(true);\n      setIsSlashCommandAIOpen(true);\n\n      // Log that we've opened the selector\n      console.log(\"AI selector opened, position set to\", { left, top });\n\n      // Debugging: Check if we can find the AI selector in the DOM after a short delay\n      setTimeout(() => {\n        const aiSelectorElements = document.querySelectorAll(\n          \".h-full.flex-col.overflow-hidden.text-popover-foreground\",\n        );\n        console.log(`Found ${aiSelectorElements.length} AI selector elements`);\n\n        const inputElements = document.querySelectorAll(\"input[placeholder*='Ask AI']\");\n        console.log(`Found ${inputElements.length} AI input elements`);\n\n        const buttonElements = document.querySelectorAll(\"button.rounded-full.bg-\\\\[\\\\#5E7CE2\\\\]\");\n        console.log(`Found ${buttonElements.length} AI submit buttons`);\n\n        // Try to find the button directly using the exact structure from the HTML\n        const exactButtonSelector =\n          \"div.relative > button.absolute.right-2.top-1\\\\/2.h-6.w-6.-translate-y-1\\\\/2.rounded-full.bg-\\\\[\\\\#5E7CE2\\\\]\";\n        const exactButton = document.querySelector(exactButtonSelector);\n        console.log(`Found exact button match: ${exactButton ? \"YES\" : \"NO\"}`);\n\n        // Try with a simpler selector\n        const simpleButtons = document.querySelectorAll(\"button\");\n        console.log(`Found ${simpleButtons.length} total buttons`);\n        simpleButtons.forEach((btn, i) => {\n          console.log(`Button ${i}: class=\"${btn.className}\", innerHTML=\"${btn.innerHTML.substring(0, 50)}...\"`);\n        });\n      }, 200);\n    }\n  }\n\n  const suggestionItems = useMemo(\n    () => getSuggestionItems(editorKey, promptForPageTitle, handlePageCreated, openAISelectorAtSelection ),\n    [editorKey, promptForPageTitle],\n  );\n  const slashCommand = useMemo(() => getSlashCommand(editorKey, promptForPageTitle), [editorKey, promptForPageTitle]);\n\n  const extensions = useMemo(\n    () => [...defaultExtensions, slashCommand, createMentionExtension(mentionUser)],\n    [slashCommand, mentionUser]\n  );\n\n  //Apply Codeblock Highlighting on the HTML from editor.getHTML()\n  const highlightCodeblocks = (content: string) => {\n    const doc = new DOMParser().parseFromString(content, \"text/html\");\n    doc.querySelectorAll(\"pre code\").forEach((el) => {\n      hljs.highlightElement(el);\n    });\n    return new XMLSerializer().serializeToString(doc);\n  };\n\n  // Nothing needed here - we're using the existing Ask AI functionality instead\n\n  const debouncedUpdates = useDebouncedCallback(async (editor: Editor) => {\n    const json = editor.getJSON();\n    window.localStorage.setItem(`html-content-${editorKey}`, highlightCodeblocks(editor.getHTML()));\n    window.localStorage.setItem(`novel-content-${editorKey}`, JSON.stringify(json));\n    window.localStorage.setItem(`markdown-${editorKey}`, editor.storage.markdown.getMarkdown());\n    window.localStorage.setItem(`offline_content_time-${editorKey}`, JSON.stringify(new Date()));\n    isDirtyRef.current = true;\n    setIsContentSynced(false);\n    setSaveStatus(\"Saved\");\n\n    if (isEditorContentEmpty(json)) {\n      prevContentRef.current = json; // mark this structure as the baseline\n      isDirtyRef.current = false;\n      return;\n    }\n\n    setTimeout(()=>{\n      if (JSON.stringify(json) == JSON.stringify(prevContentRef.current)) {\n        // If the content didn't change, don't do anything.\n        isDirtyRef.current = false;\n        return;\n      }\n    } , 500);\n    \n  }, 2000);\n\n  function updateTitleDeep(nodeList: any[], editorKey: string, newTitle: string): any[] {\n    return nodeList.map((node) => {\n      if (node.id === editorKey || node._id === editorKey) {\n        return { ...node, title: newTitle };\n      }\n\n      if (node.children && Array.isArray(node.children)) {\n        return {\n          ...node,\n          children: updateTitleDeep(node.children, editorKey, newTitle),\n        };\n      }\n\n      return node;\n    });\n  }\n\n  const handlePublish = async (editorKey: string) => {\n    setPublishLoading(true); // Start loading\n    const response = await publishNote(editorKey);\n    setPublishLoading(false); // Stop loading\n    \n    if (isPublishResponse(response) && response.approvalStatus) {\n      setPublishStatus(response.approvalStatus);\n    }\n  };\n\n  const handleInvite = async (editorKey: string, sharedWith: Invite[], isPublic: string) => {\n    \n    const response = await inviteToNote(editorKey, sharedWith, isPublic);\n    clearShareNoteId();\n\n  };\n\n  const clearShareNoteId = () => {\n    setShareNoteId(null);\n  };\n\n  const handleApproval = async (editorKey: string, approved: boolean) => {\n    setApprovalLoading(true);\n    setApprovalDirection(approved ? \"approve\" : \"reject\");\n\n    const response = await approveNote(editorKey, approved, noteOwnerMail);\n\n    // Safely access response.note if it exists\n    if (\"note\" in response && response.note) {\n      const note = response.note as NoteResponse;\n\n      if (note.approvalStatus) {\n        setApprovalStatus(note.approvalStatus);\n      }\n      if (note.githubRawUrl) {\n        setGithubRawUrl(note.githubRawUrl);\n      }\n    }\n    setApprovalLoading(false);\n    setApprovalDirection(null);\n\n  };\n\n  const debouncedUpdatesOnline = useDebouncedCallback(async (editor: Editor) => {\n    if (!socketConnected) {\n      // it helps to prevent the content loss when socket not active\n      return;\n    }\n\n    //Do not run for review or published page\n    if(noteType !== 'original') return ;\n    \n    const json = editor.getJSON();\n\n    // ✅ Do not run if not leader or not a publicNote for checking socket\n    if (isPublicNote && !isLeaderRef.current) return;\n    // Check if the content has changed\n    if (isPublicNote && !isLeaderRef.current && JSON.stringify(json) === JSON.stringify(prevContentRef.current)) {\n      isDirtyRef.current = false;\n      return; // No changes, skip API call\n    }\n\n    if (isPublicNote && JSON.stringify(json) === JSON.stringify(prevContentRef.current)) {\n      isDirtyRef.current = false;\n      return; // No changes, skip API call\n    }\n\n    if (!isPublicNote && JSON.stringify(json) === JSON.stringify(prevContentRef.current)) {\n      isDirtyRef.current = false;\n      return;\n    }\n    // if (!isPublicNote && !isLeaderRef.current) return;\n    if (JSON.stringify(json) === JSON.stringify(prevContentRef.current)) {\n      isDirtyRef.current = false;\n      return;\n    }\n\n    // Update the reference to current content\n    isDirtyRef.current = true;\n    const pageName = `docs/notes/${editorKey}`;\n\n    try {\n      const response = await postWithAuth(\n        \"/api/uploadContent\",\n        {\n          online_content: json,\n          online_content_time: new Date(),\n        },\n        {\n          headers: {\n            \"x-vercel-pagename\": pageName,\n          },\n        },\n      );\n\n      // Check if response is an error\n      if (\"isError\" in response && response.isError) {\n        console.error(\"Error saving content online:\", response.message);\n        setSaveStatus(\"Save Failed\");\n        return;\n      }\n      const uploadContentResponse = response as NoteResponse;\n      const updatedAt = uploadContentResponse?.updatedAt;\n\n      setPublishStatus(\"Publish\");\n      isDirtyRef.current = false;\n      setIsContentSynced(true);\n\n      window.localStorage.setItem(`html-content-${editorKey}`, highlightCodeblocks(editor.getHTML()));\n      window.localStorage.setItem(`novel-content-${editorKey}`, JSON.stringify(json));\n      window.localStorage.setItem(`markdown-${editorKey}`, editor.storage.markdown.getMarkdown());\n      window.localStorage.setItem(`offline_content_time-${editorKey}`, JSON.stringify(new Date()));\n      window.localStorage.setItem(`last_content_update_time-${editorKey}`, JSON.stringify(updatedAt));\n\n      setSaveStatus(\"Saved Online\");\n      prevContentRef.current = json;\n\n      let pendingTitle: string | undefined;\n      let pendingTitleParentId: string | null = null;\n      let titleIcon: string | null = null;\n      const pendingTitleObj = localStorage.getItem(`pending-title-${editorKey}`);\n\n      if (pendingTitleObj) {\n        // const pendingTitleObj = localStorage.getItem(`pending-title-${editorKey}`)\n        if (pendingTitleObj) {\n          try {\n            const parsedObj = JSON.parse(pendingTitleObj) as PendingTitle;\n            pendingTitle = parsedObj.newTitle;\n            pendingTitleParentId = parsedObj.parentId;\n            titleIcon = parsedObj.titleIcon;\n          } catch (err) {\n            console.error(\"Error in fetching new Title name\", err);\n          }\n        }\n        try {\n          await updateNote(editorKey, pendingTitle as string, pendingTitleParentId, titleIcon);\n          isTitleDirtyRef.current = false;\n          localStorage.removeItem(`pending-title-${editorKey}`);\n          delete pendingTitleMap.current[editorKey]; // ✅ Clear after successful update\n        } catch (err) {\n          toast.error(\"Error in updating name\", err);\n          console.error(\"❌ Failed to update title:\", err);\n        }\n      }\n      // After successful save, push markdown to vector DB (frontend) using ORIGINAL note owner's details\n      const markdown = editor.storage.markdown.getMarkdown();\n      const noteId = editorKey;\n      // Get current user as fallback if owner info is missing\n      const userString = window.localStorage.getItem(\"auth_user\");\n      const currentUser = userString ? JSON.parse(userString) : null;\n\n      // Use the original note owner's user ID and email instead of current user\n      // Fall back to current user only if owner info is completely missing\n      const metadata = {\n        title: editorTitle,\n        userId: noteOwnerUserId || currentUser?.id, // Prefer original owner ID\n        userEmail: noteOwnerMail || currentUser?.email, // Prefer original owner email\n        updatedAt: new Date().toISOString(),\n      };\n      // await syncMarkdownToVectorDB({ noteId, markdown, metadata });\n      return response;\n    } catch (error) {\n      console.error(\"Network error saving content online:\", error);\n      setSaveStatus(\"Save Failed\");\n    }\n  }, 10000);\n\n  useEffect(() => {\n    const pendingTitle = localStorage.getItem(`pending-title-${editorKey}`);\n    if (pendingTitle) {\n      pendingTitleMap.current[editorKey] = pendingTitle;\n      isTitleDirtyRef.current = true;\n    }\n  }, [editorKey]);\n\n  useEffect(() => {\n    isLeaderRef.current = isLeader;\n  }, [isLeader]);\n\n  useEffect(() => {\n\n    if (!editorInstance || !isLeader) return;\n    const handleUpdate = () => {\n      debouncedUpdatesOnline(editorInstance); // 👈 Only leader will trigger\n    };\n    editorInstance.on(\"update\", handleUpdate);\n\n    return () => {\n      editorInstance.off(\"update\", handleUpdate);\n    };\n  }, [editorInstance, isLeader, debouncedUpdatesOnline]);\n\n  // Handle React Query data\n  useEffect(() => {\n    // Reset handled error when editor key changes\n    if (editorKey !== prevEditorKey.current) {\n      handledErrorRef.current = null;\n      prevEditorKey.current = editorKey;\n      \n      // Check if this is a new note and reset title\n      const optimisticIds = JSON.parse(localStorage.getItem(\"optimistic-note-ids\") || \"[]\");\n      const isOptimisticNote = optimisticIds.includes(editorKey);\n      const recentlyCreated = Date.now() - parseInt(localStorage.getItem(`note-created-${editorKey}`) || \"0\") < 30000;\n      \n      if (isOptimisticNote || recentlyCreated) {\n        console.log(\"New note detected on editorKey change, resetting title\");\n        setEditorTitle(\"Untitled\");\n        setDocumentTitle(\"Untitled\");\n        setTitleIcon(\"\");\n        setPendingTitle(\"\");\n      }\n    }\n\n    // Skip invalid editorKey values\n    if (!editorKey || editorKey === \"notes\" || editorKey === \"undefined\") {\n      setInitialContent(defaultEditorContent);\n      setTimeout(() => setIsLoading(false), 300);\n      return;\n    }\n\n    if (isNoteLoading) {\n      setIsLoading(true);\n      \n      // Add a timeout to prevent infinite loading for new notes\n      const loadingTimeout = setTimeout(() => {\n        if (isNoteLoading) {\n          console.log(\"Loading timeout reached, setting default content for potential new note\");\n          const optimisticIds = JSON.parse(localStorage.getItem(\"optimistic-note-ids\") || \"[]\");\n          const isOptimisticNote = optimisticIds.includes(editorKey);\n          const recentlyCreated = Date.now() - parseInt(localStorage.getItem(`note-created-${editorKey}`) || \"0\") < 30000;\n          \n          if (isOptimisticNote || recentlyCreated) {\n            setInitialContent(defaultEditorContent);\n            setReadOnly(false);\n            setIsLoading(false);\n            \n            // Set default title for new notes and clear any cached pending title\n            setEditorTitle(\"Untitled\");\n            setDocumentTitle(\"Untitled\");\n            setTitleIcon(\"\");\n            setNoteType(\"original\");\n            setPendingTitle(\"\");\n            localStorage.removeItem(`pending-title-${editorKey}`);\n          }\n        }\n      }, 5000); // 5 second timeout\n      \n      return () => clearTimeout(loadingTimeout);\n    }\n\n    if (isNoteError && noteError) {\n      // Create a unique error key to track if we've handled this specific error\n      const errorKey = `${editorKey}-${noteError.message}`;\n\n      // Skip if we've already handled this exact error\n      if (handledErrorRef.current === errorKey) {\n        return;\n      }\n\n      // Mark this error as handled\n      handledErrorRef.current = errorKey;\n\n      // Handle errors - for new notes, 404 is expected, so create default content\n      if (noteError.message.includes(\"404\") || noteError.message.includes(\"not found\")) {\n        // Check if this might be a new note by looking for optimistic IDs or recent creation\n        const optimisticIds = JSON.parse(localStorage.getItem(\"optimistic-note-ids\") || \"[]\");\n        const isOptimisticNote = optimisticIds.includes(editorKey);\n        \n        // Also check if this is a recently created note (within last 30 seconds)\n        const recentlyCreated = Date.now() - parseInt(localStorage.getItem(`note-created-${editorKey}`) || \"0\") < 30000;\n        \n        if (isOptimisticNote || recentlyCreated) {\n          // This is a new note, set default content and allow editing\n          console.log(\"New note detected (optimistic or recently created), setting default content\");\n          setInitialContent(defaultEditorContent);\n          setReadOnly(false);\n          setIsLoading(false);\n          \n          // Set default title for new notes and clear any cached pending title\n          setEditorTitle(\"Untitled\");\n          setDocumentTitle(\"Untitled\");\n          setTitleIcon(\"\");\n          setNoteType(\"original\");\n          setPendingTitle(\"\");\n          localStorage.removeItem(`pending-title-${editorKey}`);\n          \n          return;\n        }\n        \n        window.localStorage.setItem(`404-error-${editorKey}`, \"true\");\n        window.localStorage.removeItem(`readOnly-${editorKey}`);\n        setNotFoundError({\n          noteId: editorKey,\n          message: \"Note not found\",\n        });\n      } else if (noteError.message.includes(\"403\") || noteError.message.includes(\"access denied\")) {\n        window.localStorage.removeItem(`readOnly-${editorKey}`);\n        setAccessError({\n          message: \"Access denied\",\n          status: 403,\n          error: \"NOT_AUTHORIZED\",\n          noteId: editorKey,\n        });\n      } else if (noteError.message.includes(\"Invalid note ID\")) {\n        window.localStorage.setItem(`404-error-${editorKey}`, \"true\");\n        window.localStorage.removeItem(`readOnly-${editorKey}`);\n        setNotFoundError({\n          noteId: editorKey,\n          message: \"Note not found\",\n        });\n      } else {\n        window.localStorage.removeItem(`readOnly-${editorKey}`);\n        setGenericError({\n          status: 500,\n          message: noteError.message,\n          noteId: editorKey,\n        });\n      }\n      setIsLoading(false);\n      return;\n    }\n    if (noteQueryData) {\n      // Process successful response\n      const noteResponse = noteQueryData;\n\n      // Set note metadata\n      setNoteOwnerMail(noteResponse.userEmail || \"\");\n      setPublishStatus(noteResponse.approvalStatus);\n      setApprovalStatus(noteResponse.approvalStatus);\n      setGithubRawUrl(noteResponse.githubRawUrl);\n      setIsPublish(noteResponse.isPublish);\n      setEditorTitle(noteResponse.title);\n      setDocumentTitle(noteResponse.title);\n      setTitleIcon(noteResponse.icon || \"\");\n      setIsPublicNote(noteResponse.isPublicNote || false);\n      setParentId(noteResponse.parentId || null);\n      setIsRestrictedPage(Boolean(noteResponse.isRestrictedPage));\n      setNoteType(noteResponse.noteType as string);\n      setSharedWith(noteResponse.sharedWith || []);\n      setIsCurrentNoitePublic(noteResponse.isPublicNote || false);\n      \n      // Clear any cached 404 errors for this note\n      window.localStorage.removeItem(`404-error-${editorKey}`);\n\n      // Set content if available\n      if (noteResponse.content) {\n        try {\n          const content = noteResponse.content;\n          const parsedContent = typeof content === \"string\" ? JSON.parse(content) : content;\n          const onlineContent = parsedContent.online_content;\n\n          // Validate and set content\n          if (onlineContent?.type === \"doc\") {\n            setInitialContent(onlineContent);\n            prevContentRef.current = onlineContent;\n      \n            // Cache content and ALL metadata (preserving your original caching)\n            window.localStorage.setItem(`novel-content-${editorKey}`, JSON.stringify(onlineContent));\n            window.localStorage.setItem(\n              `last_content_update_time-${editorKey}`,\n              JSON.stringify(noteResponse.updatedAt),\n            );\n            window.localStorage.setItem(`content-loaded-${editorKey}`, \"true\");\n          } else {\n            setInitialContent(defaultEditorContent);\n          }\n        } catch (e) {\n          setInitialContent(defaultEditorContent);\n        }\n      } else {\n        setInitialContent(defaultEditorContent);\n      }\n\n      // Check for shared status\n      if (noteResponse.sharedWith) {\n        const userString = window.localStorage.getItem(\"auth_user\");\n        const user = userString ? JSON.parse(userString) : null;\n        const email = user?.email;\n\n        const sharedEntry = noteResponse.sharedWith.find(\n          (entry: { email: string; access: string }) => entry.email === email,\n        );\n        if (sharedEntry) setIsSharedNote(true);\n\n        // Check write access\n        const userId = user?.id;\n        const hasWriteAccess = checkUserWriteAccess(noteResponse, userId, email);\n\n        if (!hasWriteAccess) {\n          setReadOnly(true);\n          window.localStorage.setItem(`readOnly-${editorKey}`, \"true\");\n        } else {\n          setReadOnly(false);\n          window.localStorage.setItem(`readOnly-${editorKey}`, \"false\");\n        }\n      } else {\n        // No shared data, assume user has write access for new notes\n        setReadOnly(false);\n        window.localStorage.setItem(`readOnly-${editorKey}`, \"false\");\n      }\n\n      // if(initialSyncDone === true ) {\n      //   setIsLoading(false)\n      // };\n    } else if (!isNoteLoading && !isNoteError) {\n      // Handle case where there's no data but no error either (new note or loading state)\n      const optimisticIds = JSON.parse(localStorage.getItem(\"optimistic-note-ids\") || \"[]\");\n      const isOptimisticNote = optimisticIds.includes(editorKey);\n      \n      if (isOptimisticNote) {\n        console.log(\"Setting up new optimistic note\");\n        setInitialContent(defaultEditorContent);\n        setReadOnly(false);\n        setIsLoading(false);\n        \n        // Set default title for new notes and clear any cached pending title\n        setEditorTitle(\"Untitled\");\n        setDocumentTitle(\"Untitled\");\n        setTitleIcon(\"\");\n        setNoteType(\"original\");\n        setPendingTitle(\"\");\n        localStorage.removeItem(`pending-title-${editorKey}`);\n      } else {\n        // For non-optimistic notes without data, set default content to prevent infinite loading\n        console.log(\"No data available, setting default content\");\n        setInitialContent(defaultEditorContent);\n        setReadOnly(false);\n        setIsLoading(false);\n        \n        // Set default title for new notes and clear any cached pending title\n        setEditorTitle(\"Untitled\");\n        setDocumentTitle(\"Untitled\");\n        setTitleIcon(\"\");\n        setNoteType(\"original\");\n        setPendingTitle(\"\");\n        localStorage.removeItem(`pending-title-${editorKey}`);\n      }\n    }\n  }, [noteQueryData, isNoteLoading, isNoteError, noteError, editorKey]);\n\n  useEffect(() => {\n    // Skip invalid editorKey values to prevent unnecessary API calls\n    if (!editorKey || editorKey === \"notes\" || editorKey === \"undefined\") {\n      setInitialContent(defaultEditorContent);\n      setTimeout(() => setIsLoading(false), 300);\n      return;\n    }\n\n    // For review/published pages, completely skip this useEffect\n    if (noteQueryData && (noteQueryData.noteType === 'review' || noteQueryData.noteType === 'approved')) {\n      console.log(\"Review/published page - completely skipping localStorage useEffect\");\n      return;\n    }\n    \n    // If we don't have noteQueryData yet, wait for it\n    if (!noteQueryData) {\n      return;\n    }\n\n    // Check for optimistic notes, but don't return early\n    // This allows title updates to work while still using local content\n    const optimisticIds = JSON.parse(localStorage.getItem(\"optimistic-note-ids\") || \"[]\");\n    const isOptimisticNote = optimisticIds.includes(editorKey);\n\n    if (isOptimisticNote) {\n      console.log(\"Using local content for optimistic note, but allowing API calls for metadata\");\n\n      try {\n        const local = window.localStorage.getItem(`novel-content-${editorKey}`);\n        if (local) {\n          const parsed = JSON.parse(local);\n          setInitialContent(parsed);\n          setReadOnly(false);\n          prevContentRef.current = parsed;\n\n          // Mark content as loaded to prevent unnecessary API calls for content\n          window.localStorage.setItem(`content-loaded-${editorKey}`, \"true\");\n          setIsLoading(false);\n\n          // But still allow API calls for metadata (like title updates)\n          // by continuing with the rest of the function\n        } else {\n          setInitialContent(defaultEditorContent);\n          setReadOnly(false);\n          setIsLoading(false);\n        }\n      } catch (err) {\n        console.error(\"Failed to load optimistic content\", err);\n        setInitialContent(defaultEditorContent);\n        setReadOnly(false);\n        setIsLoading(false);\n      }\n\n      return;\n    }\n\n    isDirtyRef.current = false;\n\n    setIsLoading(true);\n    setAccessError(null);\n    setNotFoundError(null);\n    setGenericError(null);\n\n    // Check if we have a very recent API call (within last 2 seconds)\n    // This helps prevent multiple calls during page refresh\n    const lastApiCheck = JSON.parse(window.localStorage.getItem(`last-api-check-${editorKey}`) || \"0\");\n    const THROTTLE_DURATION = 1000; // 1 second - reduced to make it less aggressive\n\n    // Only apply throttling if we already have content loaded\n    const hasLoadedContent = window.localStorage.getItem(`content-loaded-${editorKey}`);\n\n    if (Date.now() - lastApiCheck < THROTTLE_DURATION && hasLoadedContent) {\n      console.log(\"Throttling API call - using cached data\");\n      try {\n        const raw = window.localStorage.getItem(`novel-content-${editorKey}`);\n        if (raw && raw !== \"undefined\" && raw !== \"null\") {\n          const offline_content = JSON.parse(raw);\n          setInitialContent(offline_content);\n          prevContentRef.current = offline_content;\n\n          // if(initialSyncDone === true ) {\n          //   setIsLoading(false)\n          // };\n          return;\n        }\n      } catch (e) {\n        console.error(\"Error parsing cached content:\", e);\n      }\n    }\n\n    // Store current timestamp for throttling\n    window.localStorage.setItem(`last-api-check-${editorKey}`, JSON.stringify(Date.now()));\n\n    let offline_content = null;\n    try {\n      const raw = window.localStorage.getItem(`novel-content-${editorKey}`);\n      if (raw && raw !== \"undefined\" && raw !== \"null\") {\n        offline_content = JSON.parse(raw);\n        prevContentRef.current = offline_content;\n      }\n    } catch (e) {\n      console.error(\"Invalid JSON in localStorage for\", editorKey, e);\n      offline_content = null;\n    }\n\n    let lastUpdateTimeOfflineRaw = window.localStorage.getItem(`last_content_update_time-${editorKey}`);\n    if (!lastUpdateTimeOfflineRaw || lastUpdateTimeOfflineRaw === \"undefined\" || lastUpdateTimeOfflineRaw === \"null\") {\n      lastUpdateTimeOfflineRaw = null;\n    }\n    const lastUpadteTimeOffline = lastUpdateTimeOfflineRaw ? JSON.parse(lastUpdateTimeOfflineRaw) : null;\n\n    //check for content in local storage and getALLContent\n    if (!offline_content || offline_content === undefined) {\n      console.log(\"No local content - checking if this is a new note\");\n      \n      // Check if this might be a new note that doesn't exist yet\n      const optimisticIds = JSON.parse(localStorage.getItem(\"optimistic-note-ids\") || \"[]\");\n      const isOptimisticNote = optimisticIds.includes(editorKey);\n      \n      // Also check if this is a recently created note (within last 30 seconds)\n      const recentlyCreated = Date.now() - parseInt(localStorage.getItem(`note-created-${editorKey}`) || \"0\") < 30000;\n      \n      if (isOptimisticNote || recentlyCreated) {\n        console.log(\"New note detected in localStorage check, setting default content\");\n        setInitialContent(defaultEditorContent);\n        setReadOnly(false);\n        setIsLoading(false);\n        \n        // Set default title for new notes and clear any cached pending title\n        setEditorTitle(\"Untitled\");\n        setDocumentTitle(\"Untitled\");\n        setTitleIcon(\"\");\n        setNoteType(\"original\");\n        setPendingTitle(\"\");\n        localStorage.removeItem(`pending-title-${editorKey}`);\n        \n        return;\n      }\n      \n      console.log(\"Fetching from server with React Query\");\n      // React Query will handle this via the useEffect that watches noteQueryData\n      return;\n    }\n\n    //call the api if the content is present locally for getting last updated time of content\n    getWithAuth<NoteResponse>(`/api/getNote/${editorKey}`, {\n      headers: {\n        \"include-content\": \"false\",\n        \"content-path\": \"\",\n      },\n    })\n      .then((response) => {\n        // Check if response is an error\n        if (\"isError\" in response && response.isError) {\n          if (response.status === 404) {\n            // Cache the 404 error to prevent future API calls\n            window.localStorage.setItem(`404-error-${editorKey}`, \"true\");\n            window.localStorage.removeItem(`readOnly-${editorKey}`); // Clear cached access state\n            setNotFoundError({\n              noteId: editorKey,\n              message: response.message || \"Note not found\",\n            });\n          } else if (response.status === 403) {\n            window.localStorage.removeItem(`readOnly-${editorKey}`); // Clear cached access state\n            setAccessError({\n              message: response.message || \"Access denied\",\n              status: 403,\n              error: \"NOT_AUTHORIZED\",\n              noteId: editorKey,\n              noteTitle: undefined,\n            });\n          } else {\n            // Handle other errors (500, network errors, etc.)\n            window.localStorage.removeItem(`readOnly-${editorKey}`); // Clear cached access state\n            setGenericError({\n              status: response.status || 500,\n              message: response.message || \"An error occurred\",\n              noteId: editorKey,\n            });\n          }\n          return;\n        }\n\n        const noteResponseForTime = response as NoteResponse;\n        const lastUpdateTimeOnline = noteResponseForTime?.updatedAt;\n        const commitSha = noteResponseForTime?.commitsha as string;\n        const commitPath = noteResponseForTime.commitPath as string;\n\n        // Empty the invites for this note\n        setInvites([]);\n\n        if (lastUpadteTimeOffline < lastUpdateTimeOnline) {\n          console.log(\"Content outdated - fetching latest from server with React Query\");\n          // Use React Query to refetch with content included\n          refetchNote();\n          return;\n        }\n        \n\n        console.log(\"Using cached content - no changes detected\");\n        setInitialContent(offline_content);\n        // Mark content as loaded\n        window.localStorage.setItem(`content-loaded-${editorKey}`, \"true\");\n\n        // Type guard to ensure we have a valid NoteResponse\n        const noteResponse = response as NoteResponse;\n        const approvalStatus = noteResponse?.approvalStatus;\n        const isPublished = noteResponse?.isPublish;\n        const noteUserEmail = noteResponse?.userEmail as string;\n        const title = noteResponse?.title;\n        const icon = noteResponse?.icon as string;\n        const is_publicNote = noteResponse?.isPublicNote as boolean;\n        const parentId = noteResponse?.parentId || null;\n        const isRestrictedPage = noteResponse?.isRestrictedPage;\n        const noteType = noteResponse?.noteType as string;\n        setNoteOwnerMail(noteUserEmail);\n        setPublishStatus(approvalStatus);\n        setApprovalStatus(approvalStatus);\n        setGithubRawUrl(noteResponse.githubRawUrl);\n        setIsPublish(isPublished);\n        setEditorTitle(title);\n        setDocumentTitle(title);\n        setTitleIcon(icon);\n        setIsPublicNote(is_publicNote);\n        setIsCurrentNoitePublic(is_publicNote)\n        setParentId(parentId);\n        setIsRestrictedPage(isRestrictedPage as boolean);\n        setNoteType(noteType);\n\n        // Get user info first to check access for all notes (including those without content)\n        const userString = window.localStorage.getItem(\"auth_user\");\n        const user = userString ? JSON.parse(userString) : null;\n        const email = user?.email;\n        const userId = user?.id;\n\n        if (noteResponse?.sharedWith) {\n          const sharedEntry = noteResponse.sharedWith.find(\n            (entry: { email: string; access: string }) => entry.email === email,\n          );\n          if (sharedEntry) setIsSharedNote(true);\n        }\n\n        // Check if user has write access to this note (regardless of content)\n        const hasWriteAccess = checkUserWriteAccess(noteResponse, userId, email);\n\n        if (!hasWriteAccess) {\n          setReadOnly(true);\n          window.localStorage.setItem(`readOnly-${editorKey}`, \"true\");\n        } else {\n          setReadOnly(false);\n          window.localStorage.setItem(`readOnly-${editorKey}`, \"false\");\n        }\n\n        // set the editor content in useRef\n        if (prevEditorKey.current !== editorKey) {\n          prevContentRef.current = offline_content;\n        }\n\n        prevEditorKey.current = editorKey;\n\n        // if(initialSyncDone === true ) {\n        //   setIsLoading(false)\n        // };        \n        return;\n      })\n      .catch((error) => {\n        setIsLoading(false);\n        console.error(\"Error in fetching Last Upadted Online time \", error);\n      });\n\n    // Cleanup function\n    return () => {\n      // React Query handles request cancellation\n      // Clear cached readOnly state when editorKey changes to prevent stale cache\n      window.localStorage.removeItem(`readOnly-${editorKey}`);\n    };\n  }, [editorKey]);\n\n  // Effect to handle share modal\n  useEffect(() => {\n    if (shareNoteId) {\n      setShowModal(true);\n    }\n  }, [shareNoteId]);\n\n  useEffect(() => {\n    const pendingTitleObj = localStorage.getItem(`pending-title-${editorKey}`);\n    if (pendingTitleObj) {\n      try {\n        const parsed = JSON.parse(pendingTitleObj);\n        setPendingTitle(parsed.newTitle || \"\");\n      } catch {\n        setPendingTitle(\"\");\n      }\n    } else {\n      setPendingTitle(\"\");\n    }\n  }, [editorKey]);\n\n  useEffect(() => {\n    setShowModal(false);  \n    setInvites([]);\n    try {\n      const rootNodesRaw = localStorage.getItem(\"rootNodes\");\n      if (rootNodesRaw) {\n        const rootNodes = JSON.parse(rootNodesRaw);\n        setRootNodes(rootNodes);\n      }\n    } catch (localErr) {\n      console.error(\"Failed to update localStorage title on blur:\", localErr);\n    }\n}, []);\n\n  // Update editor's editable state when readOnly changes\n  useEffect(() => {\n    if (editorRef.current) {\n      editorRef.current.setEditable(!readOnly);\n    }\n  }, [readOnly]);\n\n  useEffect(() => {\n    function handleResize() {\n      if (aiSelectorOpen && isSlashCommandAIOpen && editorRef.current) {\n        // recalculate position\n        const selection = editorRef.current.view.state.selection;\n        const coords = editorRef.current.view.coordsAtPos(selection.from);\n        const editorContainer = editorRef.current.options.element;\n        const editorRect = editorContainer.getBoundingClientRect();\n        let left = coords.left - editorRect.left + 10;\n        const top = coords.bottom - editorRect.top + 200;\n        const aiSelectorWidth = Math.min(400, window.innerWidth * 0.9);\n        const maxLeft = Math.min(editorRect.width, window.innerWidth) - aiSelectorWidth - 20;\n        if (left > maxLeft) left = maxLeft;\n        if (left < 10) left = 10;\n        setAISelectorPosition({ left, top });\n      }\n    }\n    window.addEventListener(\"resize\", handleResize);\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, [aiSelectorOpen, isSlashCommandAIOpen]);\n\n  // If there's a not found error, show the not found page\n  if (notFoundError) {\n    return <NotFoundPage noteId={notFoundError.noteId} message={notFoundError.message} />;\n  }\n\n  // If there's a generic error, show the error page\n  if (genericError) {\n    return (\n      <ErrorPage\n        errorCode={genericError.status}\n        message={genericError.message}\n        errorId={genericError.noteId}\n        showRetry={true}\n        onRetry={() => {\n          setGenericError(null);\n          window.location.reload();\n        }}\n      />\n    );\n  }\n\n  // If there's an access error, show the no access message\n  if (accessError) {\n    return (\n      <NoAccessMessage noteId={accessError.noteId} noteTitle={accessError.noteTitle} message={accessError.message} />\n    );\n  }\n\n  if (!initialContent) {\n    return (\n      <div className=\"relative w-full p-12 pt-0\">\n        {isLoading && ( <EditorLoading/> )}\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"relative w-full p-12 pt-0 sm:p-0 \">\n        <div className=\" fixed z-20  bg-background dark:bg-background  -mt-2 p-4 w-full\" style={{ top: \"56px\" }}>\n        <div className=\"flex justify-start gap-2  p-4 pt-0 max-w-screen-lg\">\n            <div className=\"flex items-center gap-1 rounded-lg px-2 py-1 text-sm text-[#5F5E5B] dark:text-[#9B9B9B]\">\n                <span>{saveStatus}</span>\n            </div>    \n        </div>\n      </div>\n      \n      <EditorHeader\n        titleIcon={titleIcon}\n        setEditing={setEditing}\n        selectedNoteId={selectedNoteId as string}\n        editorKey={editorKey}\n        activeEmoji={activeEmoji}\n        editing={editing}\n        readOnly={readOnly}\n        inputRef={inputRef}\n        noteType={noteType}\n        noteOwnerMail={noteOwnerMail}\n        parentId={parentId}\n        user={user}\n        showCommitHistory={false}\n        setChildrenNotes={setChildrenNotes}\n        rootNodes={rootNodes}\n        setNotes={setNotes}\n        updateTitleDeep={updateTitleDeep}\n        editorTitle={editorTitle}\n        activeTitle={activeTitle}\n        pendingTitle={pendingTitle}\n        isTitleDirtyRef={isTitleDirtyRef}\n        pendingTitleMap={pendingTitleMap}\n        updateNoteWithQuery={updateNoteWithQuery}\n        updateNodeInCache={updateNodeInCache}\n        queryClient={queryClient}\n        toast={toast}\n        isOwner={isOwner}\n      />\n\n\n      <div className=\"flex-1 w-full pt-2\">\n        <EditorRoot>\n          <EditorContent\n            key={`editor-${editorKey}`}\n            // contenteditable={!readOnly}\n            initialContent={ noteType === 'original' ?  undefined : initialContent}\n            extensions={extensions}\n            onCreate={({ editor }) => {\n              editorRef.current = editor;\n              editor.setEditable(!readOnly );\n              setEditorInstance(editor);\n            }}\n            className=\"w-full h-full  bg-background dark:bg-background  p-4\"\n            editorProps={{\n              handleDOMEvents: {\n                keydown: (_view, event) => handleCommandNavigation(event),\n              },\n              handlePaste: (view, event) => handleImagePaste(view, event, uploadFn),\n              handleDrop: (view, event, _slice, moved) => handleImageDrop(view, event, moved, uploadFn),\n              attributes: {\n                class:\n                  \"prose prose-lg dark:prose-invert prose-headings:font-title font-default focus:outline-none max-w-full \",\n              },\n            }}\n            onUpdate={({ editor }) => {\n              if (!readOnly) {\n                debouncedUpdates(editor);\n                debouncedUpdatesOnline(editor);\n                setSaveStatus(\"Unsaved\");\n              }\n            }}\n            slotAfter={<ImageResizer />}\n          >\n            {aiSelectorOpen && aiSelectorPosition && isSlashCommandAIOpen && (\n              <div\n                className=\"rounded-md border bg-background dark:bg-background\"\n                style={{\n                  position: \"absolute\",\n                  left: aiSelectorPosition.left,\n                  top: aiSelectorPosition.top,\n                  zIndex: 9999,\n                }}\n              >\n                <AISelector\n                  open={aiSelectorOpen}\n                  onOpenChange={(open) => {\n                    setAISelectorOpen(open);\n                    setIsSlashCommandAIOpen(open);\n                    if (!open) {\n                      setAISelectorPosition(null);\n                    }\n                  }}\n                />\n              </div>\n            )}\n\n            <EditorCommand className=\"z-50 h-auto max-h-[330px] overflow-y-auto rounded-md border border-muted  bg-background dark:bg-background  px-1 py-2 shadow-md transition-all\">\n              <EditorCommandEmpty className=\"px-2 text-muted-foreground\">No results</EditorCommandEmpty>\n              <EditorCommandList>\n                {suggestionItems.map((item) => {\n                  if (item.title === \"Ask AI\" && !isPremiumUser) {\n                    return null;\n                  }\n                  \n                  return (\n                    <EditorCommandItem\n                      value={item.title}\n                      onCommand={(val) => item.command?.(val)}\n                      className=\"flex w-full items-center space-x-2 rounded-md px-2 py-1 text-left text-sm hover:bg-accent aria-selected:bg-accent\"\n                      key={item.title}\n                    >\n                      <div className=\"flex h-10 w-10 items-center justify-center rounded-md border border-muted bg-background dark:bg-background\">\n                        {item.icon}\n                      </div>\n                      <div>\n                        <p className=\"font-medium\">{item.title}</p>\n                        <p className=\"text-xs text-muted-foreground\">{item.description}</p>\n                      </div>\n                    </EditorCommandItem>\n                  );\n                })}\n              </EditorCommandList>\n            </EditorCommand>\n\n            <GenerativeMenuSwitch\n              open={openAI}\n              onOpenChange={(open) => {\n                setOpenAI(open);\n                if (open && isSlashCommandAIOpen) {\n                  // Close slash command AI when generative menu opens\n                  setAISelectorOpen(false);\n                  setIsSlashCommandAIOpen(false);\n                  setAISelectorPosition(null);\n                }\n              }}\n            >\n              <Separator orientation=\"vertical\" />\n              <NodeSelector open={openNode} onOpenChange={setOpenNode} />\n              <Separator orientation=\"vertical\" />\n              <LinkSelector open={openLink} onOpenChange={setOpenLink} />\n              <Separator orientation=\"vertical\" />\n              <MathSelector />\n              <Separator orientation=\"vertical\" />\n              <TextButtons />\n              <Separator orientation=\"vertical\" />\n              <ColorSelector open={openColor} onOpenChange={setOpenColor} />\n            </GenerativeMenuSwitch>\n          </EditorContent>\n        </EditorRoot>\n        {editorRef.current && <TableToolbar editor={editorRef.current} />}\n      </div>\n      {modal}\n\n      </div>\n  );\n};\n\nexport default TailwindNewEditor;\n"
          }
        ]
      }
    ]
  },
  "online_content_time": "2025-09-09T08:19:49.627Z"
}