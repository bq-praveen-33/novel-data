{
  "online_content": {
    "type": "doc",
    "content": [
      {
        "type": "codeBlock",
        "attrs": {
          "language": null
        },
        "content": [
          {
            "type": "text",
            "text": "\"use client\";\nimport { NoAccessMessage } from \"@/components/ui/no-access\";\nimport { useShare } from \"@/contexts/ShareContext\";\nimport { getWithAuth, postWithAuth } from \"@/lib/api-helpers\";\nimport type { publishResponse } from \"@/lib/api-helpers\";\nimport type { publishState } from \"@/lib/api-helpers\";\nimport { defaultEditorContent } from \"@/lib/content\";\nimport { Paperclip, Trash2, X, FileText } from \"lucide-react\";\nimport moment from \"moment\";\nimport {\n  EditorCommand,\n  EditorCommandEmpty,\n  EditorCommandItem,\n  EditorCommandList,\n  EditorContent,\n  EditorRoot,\n  ImageResizer,\n  type JSONContent,\n  handleCommandNavigation,\n  handleImageDrop,\n  handleImagePaste,\n} from \"novel\";\nimport { useEffect, useRef, useState, useMemo } from \"react\";\nimport { toast } from \"sonner\";\nimport { useDebouncedCallback } from \"use-debounce\";\nimport { ErrorPage } from \"./ErrorPage\";\nimport { NotFoundPage } from \"./NotFoundPage\";\nimport { defaultExtensions } from \"./extensions\";\nimport { uploadFn } from \"./image-upload\";\nimport { getSlashCommand, getSuggestionItems } from \"./slash-command\";\nimport { usePromptForPageTitle } from \"@/hooks/use-promptForPageTitle\";\n\nimport GenerativeMenuSwitch from \"./generative/generative-menu-switch\";\nimport { ColorSelector } from \"./selectors/color-selector\";\nimport { LinkSelector } from \"./selectors/link-selector\";\nimport { MathSelector } from \"./selectors/math-selector\";\nimport { NodeSelector } from \"./selectors/node-selector\";\nimport { Separator } from \"./ui/separator\";\nimport { TextButtons } from \"./selectors/text-buttons\";\nimport { Note } from \"@/models/Note\";\nimport HealthCheckDialog, { HealthCheckConfig } from \"./health-check-dialog\";\n\nconst hljs = require(\"highlight.js\");\n\n// Function to check if user has write access to a note\nconst checkUserWriteAccess = (note: NoteResponse, userId?: string, userEmail?: string): boolean => {\n  if (!note || !userEmail) return false;\n\n  if (note && note.isPublish === true) return false;\n\n  // Check if user is the owner (by email - primary check)\n  if (note.userEmail && note.userEmail === userEmail) return true;\n\n  // For notes without userEmail, only allow access if it's a newly created note (no id or content)\n  // This prevents access to existing notes that might be missing user info\n  if (!note.userEmail) {\n    // If the note has content or a proper ID, it's an existing note - be more restrictive\n    if (note.content || (note.id && note.id !== \"undefined\" && note.id !== \"notes\")) {\n      return false;\n    }\n    // Only allow access for truly new/empty notes\n    return true;\n  }\n\n  // Check public write access (isPublic === 2 means public read/write)\n  if (note.isPublic === 2) return true;\n\n  // Check if user has write access through sharing (if userId is available)\n  // Note: userId might not be available in localStorage, so this is secondary\n  if (userId && note.sharedWith) {\n    const sharedEntry = note.sharedWith.find(\n      (entry: { userId: string; access: string }) => entry.userId?.toString() === userId?.toString(),\n    );\n    if (sharedEntry && sharedEntry.access === \"write\") return true;\n  }\n\n  return false;\n};\ninterface NoteContent {\n  online_content: JSONContent;\n  online_content_time: string;\n}\n\ninterface NoteResponse {\n  id: string;\n  icon: string;\n  title: string;\n  content: NoteContent;\n  userId?: string;\n  userEmail?: string;\n  isPublic?: number;\n  sharedWith?: Array<{ userId: string; access: string }>;\n  status?: number;\n  message?: string;\n  error?: string;\n  noteId?: string;\n  noteTitle?: string;\n  [key: string]: unknown;\n  isPublish: boolean;\n  approvalStatus: publishState;\n  githubRawUrl: string;\n  updatedAt: string;\n}\n\ninterface ApiError {\n  message: string;\n  status: number;\n  error?: string;\n  noteId?: string;\n  noteTitle?: string;\n}\n\ninterface AdvancedEditorProps {\n  editorKey: string;\n  shareNoteId?: string | null;\n  onShareComplete?: () => void;\n}\n\ntype Invite = {\n  email: string;\n  permission: \"read\" | \"write\";\n};\n\ninterface HealthCheck {\n  id: string;\n  url: string;\n  method: string;\n  port?: string;\n  /** Interval in milliseconds */\n  interval: number;\n  webhook?: string;\n  status: \"pending\" | \"up\" | \"down\";\n  totalUptime?: number;\n  totalDowntime?: number;\n  lastDownAt?: string;\n}\n\nconst handleInvite = async (editorKey: string, sharedWith: Invite[], isPublic: string) => {\n  try {\n    const response = await postWithAuth(`/api/share/${editorKey}`, {\n      noteId: editorKey,\n      sharedWith,\n      isPublic,\n    });\n\n    // Check if response is an error\n    if (\"isError\" in response && response.isError) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const errorResponse = response as any;\n      toast.error(errorResponse.message || \"Failed to send invites. Please try again.\");\n      return;\n    }\n\n    toast.success(\"Invitation Sent\");\n  } catch (err) {\n    console.error(\"Error sending invites:\", err);\n    toast.error(\"Network error. Please check your connection and try again.\");\n  }\n};\nfunction isPublishResponse(response: unknown): response is publishResponse {\n  return (\n    typeof response === \"object\" &&\n    response !== null &&\n    \"approvalStatus\" in response &&\n    typeof (response as any).approvalStatus === \"string\"\n  );\n}\n\nconst TailwindAdvancedEditor = ({ editorKey, shareNoteId, onShareComplete }: AdvancedEditorProps) => {\n  const [initialContent, setInitialContent] = useState<JSONContent | null>(null);\n  const [saveStatus, setSaveStatus] = useState<\"Saving...\" | \"Saved\" | \"Save Failed\" | \"Saved Online\" | \"Unsaved\">(\n    \"Saved\",\n  );\n\n  const [openNode, setOpenNode] = useState(false);\n  const [openColor, setOpenColor] = useState(false);\n  const [openLink, setOpenLink] = useState(false);\n  const [openAI, setOpenAI] = useState(false);\n\n  const [isLoading, setIsLoading] = useState(true);\n  const [accessError, setAccessError] = useState<ApiError | null>(null);\n  const [notFoundError, setNotFoundError] = useState<{ noteId: string; message: string } | null>(null);\n  const [genericError, setGenericError] = useState<{ status: number; message: string; noteId?: string } | null>(null);\n  const [showModal, setShowModal] = useState(false);\n  const [newEmail, setNewEmail] = useState(\"\");\n  const [newPermission, setNewPermission] = useState<\"read\" | \"write\">(\"read\");\n  const [invites, setInvites] = useState<Invite[]>([{ email: \"\", permission: \"read\" }]);\n  const [generalAccess, setGeneralAccess] = useState(\"restricted\");\n  const [copied, setCopied] = useState(false);\n  const [readOnly, setReadOnly] = useState(false);\n  const [showHealthDialog, setShowHealthDialog] = useState(false);\n  const [healthChecks, setHealthChecks] = useState<HealthCheck[]>([]);\n  const { setShareNoteId } = useShare();\n  const [publishLoading, setPublishLoading] = useState(false);\n  const [approvalLoading, setApprovalLoading] = useState(false);\n  const [approvalDirection, setApprovalDirection] = useState<\"approve\" | \"reject\" | null>(null);\n  const [approvalStatus, setApprovalStatus] = useState(\"\");\n  const [githubRawUrl, setGithubRawUrl] = useState(\"\");\n\n  const [publishStatus, setPublishStatus] = useState<publishState>();\n  const [isPublish, setIsPublish] = useState(Boolean);\n  const [noteOwnerMail, setNoteOwnerMail] = useState<string>(\"\");\n  const [editorTitle, setEditorTitle] = useState<string>(\"Title\");\n  const [titleIcon, setTitleIcon] = useState(\"\");\n  const prevContentRef = useRef<any>(null);\n  const [isPublicNote, setIsPublicNote] = useState(false);\n\n  const { promptForPageTitle, modal } = usePromptForPageTitle();\n\n  // Add a ref to track if we're already fetching to prevent duplicate calls\n  const isFetchingRef = useRef(false);\n  const abortControllerRef = useRef<AbortController | null>(null);\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const editorRef = useRef<any | null>(null); // Store editor instance - any needed for Novel editor API\n\n  const suggestionItems = useMemo(\n    () => getSuggestionItems(editorKey, promptForPageTitle),\n    [editorKey, promptForPageTitle],\n  );\n  const slashCommand = useMemo(() => getSlashCommand(editorKey, promptForPageTitle), [editorKey, promptForPageTitle]);\n  const extensions = useMemo(() => [...defaultExtensions, slashCommand], [slashCommand]);\n\n  //Apply Codeblock Highlighting on the HTML from editor.getHTML()\n  const highlightCodeblocks = (content: string) => {\n    const doc = new DOMParser().parseFromString(content, \"text/html\");\n    doc.querySelectorAll(\"pre code\").forEach((el) => {\n      hljs.highlightElement(el);\n    });\n    return new XMLSerializer().serializeToString(doc);\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const debouncedUpdates = useDebouncedCallback(async (editor: any) => {\n    const json = editor.getJSON();\n    window.localStorage.setItem(`html-content-${editorKey}`, highlightCodeblocks(editor.getHTML()));\n    window.localStorage.setItem(`novel-content-${editorKey}`, JSON.stringify(json));\n    window.localStorage.setItem(`markdown-${editorKey}`, editor.storage.markdown.getMarkdown());\n    window.localStorage.setItem(`offline_content_time-${editorKey}`, JSON.stringify(new Date()));\n\n    setSaveStatus(\"Saved\");\n  }, 500);\n\n  const handlePublish = async (editorKey: string, setPublishStatus) => {\n    try {\n      setPublishLoading(true); // Start loading\n      const response = await postWithAuth(`/api/publishNote`, { id: editorKey });\n\n      if (\"isError\" in response && response.isError) {\n        const errorResponse = response as any;\n        toast.error(errorResponse.message || \"Failed to Publish. Please try again.\");\n        return;\n      }\n\n      if (isPublishResponse(response) && response.approvalStatus) {\n        setPublishStatus(response.approvalStatus);\n      }\n    } catch (error) {\n      console.error(\"Error in Publishing:\", error);\n      toast.error(\"There is an error in publishing. Please check your connection and try again.\");\n    } finally {\n      setPublishLoading(false); // Stop loading\n    }\n  };\n\n  const handleApproval = async (editorKey: string, approved: boolean) => {\n    try {\n      setApprovalLoading(true);\n      setApprovalDirection(approved ? \"approve\" : \"reject\");\n\n      if (!noteOwnerMail) {\n        toast.error(\"Could not determine note owner. Please try publishing again.\");\n        return;\n      }\n\n      const response = await postWithAuth(`/api/give-approval`, {\n        noteId: editorKey,\n        approved,\n        email: noteOwnerMail,\n      });\n\n      // Check if response is an error\n      if (\"isError\" in response && response.isError) {\n        toast.error((response.message as any) || \"Failed to Approve or Reject. Please try again.\");\n        return;\n      }\n\n      // Safely access response.note if it exists\n      if (\"note\" in response && response.note) {\n        const note = response.note as NoteResponse;\n\n        if (note.approvalStatus) {\n          setApprovalStatus(note.approvalStatus);\n        }\n\n        if (note.githubRawUrl) {\n          setGithubRawUrl(note.githubRawUrl);\n        }\n      }\n\n      toast.success((response.message as any) || \"Action successful!\");\n    } catch (error) {\n      console.error(\"Error in Approval:\", error);\n      toast.error(\"There was an error. Please check your connection and try again.\");\n    } finally {\n      setApprovalLoading(false);\n      setApprovalDirection(null);\n    }\n  };\n\n  const updateHealthStatus = (\n    id: string,\n    status: \"up\" | \"down\" | \"pending\",\n    extra?: { totalUptime?: number; totalDowntime?: number; lastDownAt?: string },\n  ) => {\n    setHealthChecks((prev) => prev.map((c) => (c.id === id ? { ...c, status, ...extra } : c)));\n    if (editorRef.current) {\n      let pos: number | null = null;\n      editorRef.current.state.doc.descendants((node, position) => {\n        if (node.type.name === \"healthCheck\" && node.attrs.id === id) {\n          pos = position;\n          return false;\n        }\n      });\n      if (pos !== null) {\n        editorRef.current.commands.command(({ tr }) => {\n          const node = tr.doc.nodeAt(pos!);\n          if (node) {\n            tr.setNodeMarkup(pos!, undefined, {\n              ...node.attrs,\n              status,\n              totalUptime: extra?.totalUptime,\n              totalDowntime: extra?.totalDowntime,\n              lastDownAt: extra?.lastDownAt,\n            });\n          }\n          return true;\n        });\n      }\n    }\n  };\n\n  const addHealthCheck = async (config: HealthCheckConfig) => {\n    const res = await fetch(\"/api/health\", {\n      method: \"POST\",\n      headers: { \"content-type\": \"application/json\" },\n      body: JSON.stringify({\n        endpoint: config.url,\n        method: config.method,\n        interval: config.interval,\n        webhookUrl: config.webhook,\n      }),\n    });\n    const data = await res.json();\n    const id = data._id as string;\n    const intervalMs = (data.interval || config.interval) * 1000;\n    const check: HealthCheck = {\n      id,\n      url: data.endpoint,\n      method: data.method,\n      interval: intervalMs,\n      webhook: data.webhookUrl,\n      status: \"pending\",\n      totalUptime: data.totalUptime,\n      totalDowntime: data.totalDowntime,\n      lastDownAt: data.lastDownAt ? new Date(data.lastDownAt).toISOString() : undefined,\n    };\n    setHealthChecks((prev) => [...prev, check]);\n    if (editorRef.current) {\n      editorRef.current\n        .chain()\n        .focus()\n        // @ts-ignore - command injected by extension\n        .insertHealthCheck({\n          id,\n          url: check.url,\n          method: check.method,\n          interval: intervalMs,\n          webhook: check.webhook,\n          status: check.status,\n          totalUptime: check.totalUptime,\n          totalDowntime: check.totalDowntime,\n          lastDownAt: check.lastDownAt,\n        })\n        .run();\n    }\n  };\n\n  const syncHealthChecks = () => {\n    if (!editorRef.current) return;\n    const ids: string[] = [];\n    editorRef.current.state.doc.descendants((node) => {\n      if (node.type.name === \"healthCheck\") {\n        ids.push(node.attrs.id);\n      }\n    });\n    setHealthChecks((prev) => prev.filter((c) => ids.includes(c.id)));\n  };\n\n  useEffect(() => {\n    if (!editorRef.current) return;\n    const nodes: HealthCheck[] = [];\n    editorRef.current.state.doc.descendants((node) => {\n      if (node.type.name === \"healthCheck\") {\n        nodes.push({\n          id: node.attrs.id,\n          url: node.attrs.url,\n          method: node.attrs.method,\n          port: node.attrs.port,\n          interval: node.attrs.interval,\n          webhook: node.attrs.webhook,\n          status: node.attrs.status || \"pending\",\n          totalUptime: node.attrs.totalUptime,\n          totalDowntime: node.attrs.totalDowntime,\n          lastDownAt: node.attrs.lastDownAt,\n        });\n      }\n    });\n    setHealthChecks(nodes);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [initialContent, editorRef.current]);\n\n  const getAllContent = async (editorKey: string, abortController, commitSha: string = \"\", commitPath: string = \"\") => {\n    getWithAuth<NoteResponse>(`/api/getNote/${editorKey}`, {\n      headers: {\n        \"include-content\": \"true\",\n        commitSha: `${commitSha}`,\n        commitPath: `${commitPath}`,\n      },\n    })\n      .then((response) => {\n        // Check if request was aborted\n        if (abortController.signal.aborted) {\n          return;\n        }\n\n        // Empty the invites for this note\n        setInvites([]);\n\n        // Store the API check time\n        window.localStorage.setItem(`last-api-check-${editorKey}`, JSON.stringify(Date.now()));\n\n        // Check if response is an error\n        if (\"isError\" in response && response.isError) {\n          if (response.status === 404) {\n            // Cache the 404 error to prevent future API calls\n            window.localStorage.setItem(`404-error-${editorKey}`, \"true\");\n            window.localStorage.removeItem(`readOnly-${editorKey}`); // Clear cached access state\n            setNotFoundError({\n              noteId: editorKey,\n              message: response.message || \"Note not found\",\n            });\n          } else if (response.status === 403) {\n            window.localStorage.removeItem(`readOnly-${editorKey}`); // Clear cached access state\n            setAccessError({\n              message: response.message || \"Access denied\",\n              status: 403,\n              error: \"NOT_AUTHORIZED\",\n              noteId: editorKey,\n              noteTitle: undefined,\n            });\n          } else {\n            // Handle other errors (500, network errors, etc.)\n            window.localStorage.removeItem(`readOnly-${editorKey}`); // Clear cached access state\n            setGenericError({\n              status: response.status || 500,\n              message: response.message || \"An error occurred\",\n              noteId: editorKey,\n            });\n          }\n          return;\n        }\n\n        // Clear any cached 404 error if the note is found\n        window.localStorage.removeItem(`404-error-${editorKey}`);\n\n        // Type guard to ensure we have a valid NoteResponse\n        const noteResponse = response as NoteResponse;\n        const approvalStatus = noteResponse?.approvalStatus;\n        const isPublished = noteResponse?.isPublish;\n        const noteUserEmail = noteResponse?.userEmail as string;\n        const title = noteResponse?.title;\n        const icon = noteResponse?.icon as string;\n        const content = noteResponse?.content;\n        const updatedAt = noteResponse?.updatedAt;\n        const is_publicNote = noteResponse?.isPublicNote as boolean;\n        //set items in local storage\n        window.localStorage.setItem(`last_content_update_time-${editorKey}`, JSON.stringify(updatedAt));\n\n        setNoteOwnerMail(noteUserEmail);\n        setPublishStatus(approvalStatus);\n        setApprovalStatus(approvalStatus);\n        setGithubRawUrl(noteResponse.githubRawUrl);\n        setIsPublish(isPublished);\n        setEditorTitle(title);\n        setTitleIcon(icon);\n        setIsPublicNote(is_publicNote);\n\n        // Get user info first to check access for all notes (including those without content)\n        const userString = window.localStorage.getItem(\"auth_user\");\n        const user = userString ? JSON.parse(userString) : null;\n        const email = user?.email;\n        const userId = user?.id;\n\n        // Check if user has write access to this note (regardless of content)\n        const hasWriteAccess = checkUserWriteAccess(noteResponse, userId, email);\n\n        if (!hasWriteAccess) {\n          setReadOnly(true);\n          window.localStorage.setItem(`readOnly-${editorKey}`, \"true\");\n        } else {\n          setReadOnly(false);\n          window.localStorage.setItem(`readOnly-${editorKey}`, \"false\");\n        }\n\n        // Check if response content exists\n        if (!noteResponse.content) {\n          // Handle access denied response\n          if (noteResponse.error === \"NOT_AUTHORIZED\") {\n            setAccessError({\n              message: noteResponse.message || \"You don't have access to this note\",\n              status: 403,\n              error: noteResponse.error,\n              noteId: noteResponse.noteId,\n              noteTitle: noteResponse.noteTitle,\n            });\n            return;\n          }\n\n          setInitialContent(defaultEditorContent);\n          return;\n        }\n\n        const contentData = noteResponse.content;\n        const parsedContent = typeof contentData === \"string\" ? JSON.parse(contentData) : contentData;\n        const { online_content, online_content_time } = parsedContent;\n\n        window.localStorage.setItem(`novel-content-${editorKey}`, JSON.stringify(online_content));\n        setInitialContent(online_content ?? defaultEditorContent);\n\n        // set the editor content in useRef\n        prevContentRef.current = online_content;\n\n        // if (\n        //   offline_content_time &&\n        //   online_content_time &&\n        //   moment(offline_content_time).isBefore(moment(online_content_time))\n        // ) {\n        //   if (online_content) {\n        //     setInitialContent(online_content);\n        //     // Update localStorage with newer online content\n        //     window.localStorage.setItem(`novel-content-${editorKey}`, JSON.stringify(online_content));\n        //     window.localStorage.setItem(`offline_content_time-${editorKey}`, JSON.stringify(new Date()));\n        //   } else {\n        //     setInitialContent(defaultEditorContent);\n        //   }\n        // } else {\n        //   if (offline_content) {\n        //     setInitialContent(offline_content);\n        //   } else if (online_content) {\n        //     setInitialContent(online_content);\n        //     // Store online content if we don't have offline content\n        //     window.localStorage.setItem(`novel-content-${editorKey}`, JSON.stringify(online_content));\n        //     window.localStorage.setItem(`offline_content_time-${editorKey}`, JSON.stringify(new Date()));\n        //   } else {\n        //     setInitialContent(defaultEditorContent);\n        //   }\n        // }\n      })\n      .catch((error) => {\n        // Check if request was aborted\n        if (abortController.signal.aborted) {\n          return;\n        }\n\n        console.error(\"Error fetching or processing note:\", error);\n        window.localStorage.setItem(`last-api-check-${editorKey}`, JSON.stringify(Date.now()));\n\n        // Handle network or other errors\n        setGenericError({\n          status: 0,\n          message: \"Network error. Please check your connection and try again.\",\n          noteId: editorKey,\n        });\n      })\n      .finally(() => {\n        // Check if request was aborted\n        if (!abortController.signal.aborted) {\n          isFetchingRef.current = false;\n          setTimeout(() => setIsLoading(false), 300);\n        }\n      });\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const debouncedUpdatesOnline = useDebouncedCallback(async (editor: any) => {\n    const json = editor.getJSON();\n\n    // Check if the content has changed\n    if (JSON.stringify(json) === JSON.stringify(prevContentRef.current)) {\n      return; // No changes, skip API call\n    }\n    // Update the reference to current content\n    prevContentRef.current = json;\n    const pageName = `docs/notes/${editorKey}`;\n\n    try {\n      const response = await postWithAuth(\n        \"/api/uploadContent\",\n        {\n          online_content: json,\n          online_content_time: new Date(),\n        },\n        {\n          headers: {\n            \"x-vercel-pagename\": pageName,\n          },\n        },\n      );\n\n      // Check if response is an error\n      if (\"isError\" in response && response.isError) {\n        console.error(\"Error saving content online:\", response.message);\n        setSaveStatus(\"Save Failed\");\n        return;\n      }\n      const uploadContentResponse = response as NoteResponse;\n      const updatedAt = uploadContentResponse?.updatedAt;\n\n      setPublishStatus(\"Publish\");\n      window.localStorage.setItem(`html-content-${editorKey}`, highlightCodeblocks(editor.getHTML()));\n      window.localStorage.setItem(`novel-content-${editorKey}`, JSON.stringify(json));\n      window.localStorage.setItem(`markdown-${editorKey}`, editor.storage.markdown.getMarkdown());\n      window.localStorage.setItem(`offline_content_time-${editorKey}`, JSON.stringify(new Date()));\n      window.localStorage.setItem(`last_content_update_time-${editorKey}`, JSON.stringify(updatedAt));\n\n      setSaveStatus(\"Saved Online\");\n    } catch (error) {\n      console.error(\"Network error saving content online:\", error);\n      setSaveStatus(\"Save Failed\");\n    }\n  }, 10000);\n\n  useEffect(() => {\n    // Skip invalid editorKey values to prevent unnecessary API calls\n    if (!editorKey || editorKey === \"notes\" || editorKey === \"undefined\") {\n      setInitialContent(defaultEditorContent);\n      setTimeout(() => setIsLoading(false), 300);\n      return;\n    }\n\n    // Cancel any previous request\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n\n    // Create new abort controller\n    const abortController = new AbortController();\n    abortControllerRef.current = abortController;\n\n    // Prevent multiple simultaneous calls\n    if (isFetchingRef.current) {\n      return;\n    }\n    setIsLoading(true);\n    setAccessError(null);\n    setNotFoundError(null);\n    setGenericError(null);\n\n    let offline_content = null;\n    try {\n      const raw = window.localStorage.getItem(`novel-content-${editorKey}`);\n      if (raw && raw !== \"undefined\" && raw !== \"null\") {\n        offline_content = JSON.parse(raw);\n      }\n    } catch (e) {\n      console.error(\"Invalid JSON in localStorage for\", editorKey, e);\n      offline_content = null;\n    }\n    const offline_content_time = JSON.parse(window.localStorage.getItem(`offline_content_time-${editorKey}`) || \"null\");\n    const last_api_check = JSON.parse(window.localStorage.getItem(`last-api-check-${editorKey}`) || \"null\");\n    const cached_404 = window.localStorage.getItem(`404-error-${editorKey}`);\n    const CACHE_DURATION = 1 * 1000; // decreased to 1 seconds\n    const lastUpadteTimeOffline = JSON.parse(\n      window.localStorage.getItem(`last_content_update_time-${editorKey}`) || \"null\",\n    );\n\n    //check for content in local storage and getALLContent\n    if (!offline_content || offline_content === undefined) {\n      console.log(\"Calling till github\");\n      getAllContent(editorKey, abortController);\n      return;\n    }\n\n    //call the api if the content is  present locally for getting last updated time of content\n    getWithAuth<NoteResponse>(`/api/getNote/${editorKey}`, {\n      headers: {\n        \"include-content\": \"false\",\n        \"content-path\": \"\",\n      },\n    })\n      .then((response) => {\n        // Check if response is an error\n        if (\"isError\" in response && response.isError) {\n          if (response.status === 404) {\n            // Cache the 404 error to prevent future API calls\n            window.localStorage.setItem(`404-error-${editorKey}`, \"true\");\n            window.localStorage.removeItem(`readOnly-${editorKey}`); // Clear cached access state\n            setNotFoundError({\n              noteId: editorKey,\n              message: response.message || \"Note not found\",\n            });\n          } else if (response.status === 403) {\n            window.localStorage.removeItem(`readOnly-${editorKey}`); // Clear cached access state\n            setAccessError({\n              message: response.message || \"Access denied\",\n              status: 403,\n              error: \"NOT_AUTHORIZED\",\n              noteId: editorKey,\n              noteTitle: undefined,\n            });\n          } else {\n            // Handle other errors (500, network errors, etc.)\n            window.localStorage.removeItem(`readOnly-${editorKey}`); // Clear cached access state\n            setGenericError({\n              status: response.status || 500,\n              message: response.message || \"An error occurred\",\n              noteId: editorKey,\n            });\n          }\n        }\n\n        const noteResponseForTime = response as NoteResponse;\n        const lastUpdateTimeOnline = noteResponseForTime?.updatedAt;\n        const commitSha = noteResponseForTime?.commitsha as string;\n        const commitPath = noteResponseForTime.commitPath as string;\n\n        // Empty the invites for this note\n        setInvites([]);\n\n        if (lastUpadteTimeOffline < lastUpdateTimeOnline) {\n          console.log(\"In Calling only for mongoDb time\");\n          getAllContent(editorKey, abortController, commitSha, commitPath);\n          return;\n        }\n        console.log(\"resposne\", response);\n        console.log(\"Fetching content from Local\");\n        setInitialContent(offline_content);\n\n        // Type guard to ensure we have a valid NoteResponse\n        const noteResponse = response as NoteResponse;\n        const approvalStatus = noteResponse?.approvalStatus;\n        const isPublished = noteResponse?.isPublish;\n        const noteUserEmail = noteResponse?.userEmail as string;\n        const title = noteResponse?.title;\n        const icon = noteResponse?.icon as string;\n        const is_publicNote = noteResponse?.isPublicNote as boolean;\n\n        setNoteOwnerMail(noteUserEmail);\n        setPublishStatus(approvalStatus);\n        setApprovalStatus(approvalStatus);\n        setGithubRawUrl(noteResponse.githubRawUrl);\n        setIsPublish(isPublished);\n        setEditorTitle(title);\n        setTitleIcon(icon);\n        setIsPublicNote(is_publicNote);\n\n        // Get user info first to check access for all notes (including those without content)\n        const userString = window.localStorage.getItem(\"auth_user\");\n        const user = userString ? JSON.parse(userString) : null;\n        const email = user?.email;\n        const userId = user?.id;\n\n        // Check if user has write access to this note (regardless of content)\n        const hasWriteAccess = checkUserWriteAccess(noteResponse, userId, email);\n\n        if (!hasWriteAccess) {\n          setReadOnly(true);\n          window.localStorage.setItem(`readOnly-${editorKey}`, \"true\");\n        } else {\n          setReadOnly(false);\n          window.localStorage.setItem(`readOnly-${editorKey}`, \"false\");\n        }\n\n        // set the editor content in useRef\n        prevContentRef.current = offline_content;\n\n        // Check if response content exists\n        // if (!noteResponse.content) {\n        //   // Handle access denied response\n        //   if (noteResponse.error === \"NOT_AUTHORIZED\") {\n        //     setAccessError({\n        //       message: noteResponse.message || \"You don't have access to this note\",\n        //       status: 403,\n        //       error: noteResponse.error,\n        //       noteId: noteResponse.noteId,\n        //       noteTitle: noteResponse.noteTitle,\n        //     });\n        //     return;\n        //   }\n        // }\n\n        setIsLoading(false);\n        return;\n      })\n      .catch((error) => {\n        setIsLoading(false);\n        console.error(\"Error in fetching Last Upadted Online time \", error);\n      });\n\n    // // If we have a cached 404 error, show it immediately\n    // if (cached_404 && last_api_check && Date.now() - last_api_check < CACHE_DURATION) {\n    //   window.localStorage.removeItem(`readOnly-${editorKey}`); // Clear cached access state\n    //   setNotFoundError({\n    //     noteId: editorKey,\n    //     message: \"The note you're looking for doesn't exist or may have been deleted.\",\n    //   });\n    //   setIsLoading(false);\n\n    //   return;\n    // }\n\n    // If we have offline content and it's been less than 30 seconds since last API check\n    // if (offline_content && last_api_check && Date.now() - last_api_check < CACHE_DURATION) {\n    //   setInitialContent(offline_content);\n\n    //   // Check cached readOnly state - if not available, we need to fetch to determine access\n\n    //   const cachedReadOnly = window.localStorage.getItem(`readOnly-${editorKey}`);\n    //   if (cachedReadOnly !== null) {\n    //     setReadOnly(cachedReadOnly === \"true\");\n    //     setIsLoading(false);\n    //     return;\n    //   }\n    //   // If no cached readOnly state, continue to API call to determine access\n    // }\n    // // Set fetching flag\n    // isFetchingRef.current = true;\n\n    // Use getWithAuth for authenticated request\n\n    // Cleanup function\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n      isFetchingRef.current = false;\n      // Clear cached readOnly state when editorKey changes to prevent stale cache\n      window.localStorage.removeItem(`readOnly-${editorKey}`);\n    };\n  }, [editorKey]);\n\n  // Effect to handle share modal\n  useEffect(() => {\n    if (shareNoteId) {\n      setShowModal(true);\n    }\n  }, [shareNoteId]);\n\n  useEffect(() => {\n    const handler = () => setShowHealthDialog(true);\n    window.addEventListener(\"open-health-check-dialog\", handler);\n    return () => window.removeEventListener(\"open-health-check-dialog\", handler);\n  }, []);\n\n  useEffect(() => {\n    const fetchStatuses = async () => {\n      try {\n        const res = await fetch(\"/api/health\");\n        const data = await res.json();\n        data.forEach((c: any) => {\n          const status: \"up\" | \"down\" | \"pending\" =\n            c.lastStatus === undefined ? \"pending\" : c.lastStatus >= 200 && c.lastStatus < 400 ? \"up\" : \"down\";\n          updateHealthStatus(c._id, status, {\n            totalUptime: c.totalUptime,\n            totalDowntime: c.totalDowntime,\n            lastDownAt: c.lastDownAt ? new Date(c.lastDownAt).toISOString() : undefined,\n          });\n        });\n      } catch {\n        // ignore\n      }\n    };\n    const interval = setInterval(fetchStatuses, 10000);\n    fetchStatuses();\n    return () => clearInterval(interval);\n  }, []);\n\n  useEffect(() => {\n    setShowModal(false);\n  }, []);\n\n  // Update editor's editable state when readOnly changes\n  useEffect(() => {\n    if (editorRef.current) {\n      editorRef.current.setEditable(!readOnly);\n    }\n  }, [readOnly]);\n\n  // If there's a not found error, show the not found page\n  if (notFoundError) {\n    return <NotFoundPage noteId={notFoundError.noteId} message={notFoundError.message} />;\n  }\n\n  // If there's a generic error, show the error page\n  if (genericError) {\n    return (\n      <ErrorPage\n        errorCode={genericError.status}\n        message={genericError.message}\n        errorId={genericError.noteId}\n        showRetry={true}\n        onRetry={() => {\n          setGenericError(null);\n          window.location.reload();\n        }}\n      />\n    );\n  }\n\n  // If there's an access error, show the no access message\n  if (accessError) {\n    return (\n      <NoAccessMessage noteId={accessError.noteId} noteTitle={accessError.noteTitle} message={accessError.message} />\n    );\n  }\n\n  if (!initialContent) {\n    return (\n      <div className=\"relative w-full p-12 pt-0\">\n        {isLoading && (\n          <div className=\"min-h-[500px] w-full  bg-background sm:rounded-lg  p-5\">\n            <div className=\"flex items-center gap-2 mb-4\">\n              <div className=\"relative w-4 h-4\">\n                <div className=\"absolute inset-0 border-2 border-gray-400 dark:border-gray-500 border-t-transparent rounded-full animate-spin\" />\n              </div>\n              <span className=\"text-sm font-medium text-gray-600 dark:text-gray-300\">Loading content...</span>\n            </div>\n            <div className=\"space-y-3\">\n              <div className=\"h-7 w-3/4 bg-gray-200 dark:bg-zinc-800 rounded animate-pulse\" />\n              <div className=\"h-4 w-full bg-gray-200 dark:bg-zinc-800 rounded animate-pulse\" />\n              <div className=\"h-4 w-full bg-gray-200 dark:bg-zinc-800 rounded animate-pulse\" />\n              <div className=\"h-4 w-2/3 bg-gray-200 dark:bg-zinc-800 rounded animate-pulse\" />\n              <div className=\"h-24 w-full bg-gray-200 dark:bg-zinc-800 rounded animate-pulse mt-6\" />\n            </div>\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"relative w-full p-12 pt-0 sm:p-0 \">\n      <div className=\" fixed top-20 z-10 bg-background p-4 w-full\">\n        <div className=\"flex justify-start gap-2  p-4 pt-0 pl-12 max-w-screen-lg\">\n          {isPublish ? (\n            <>\n              {approvalStatus === \"accepted\" && (\n                <button\n                  type=\"button\"\n                  className=\"px-3 py-1 text-sm bg-accent rounded-lg text-muted-foreground hover:text-gray-700 dark:hover:text-gray-100 font-semibold\"\n                  onClick={(e) => {\n                    e.stopPropagation();\n                    // navigator.clipboard.writeText(githubRawUrl);\n                    navigator.clipboard.writeText(window.location.href);\n                    toast.success(\"Link copied to clipboard!\");\n                  }}\n                >\n                  Copy Link\n                </button>\n              )}\n\n              {approvalStatus === \"rejected\" && (\n                <div className=\"px-3 py-1 text-sm bg-accent rounded-lg text-red-500 font-semibold\">Rejected</div>\n              )}\n              <div className=\"rounded-lg bg-accent px-2 py-1 text-sm text-muted-foreground\">\n                {readOnly ? \"Read Only\" : saveStatus}\n              </div>\n              {approvalStatus === \"pending\" && (\n                <>\n                  <div className=\" pl-2 pr-2 rounded-lg bg-accent px-2 py-1 text-sm text-muted-foreground\">\n                    <button\n                      type=\"button\"\n                      className=\" text-gray-500 hover:text-gray-700 dark:text-gray-300 hover:dark:text-gray-100 font-semibold rounded-sm\"\n                      onClick={(e) => {\n                        e.stopPropagation();\n                        handleApproval(editorKey, true);\n                      }}\n                      disabled={approvalLoading}\n                    >\n                      {approvalLoading && approvalDirection === \"approve\" ? \"Approving...\" : \"Approve\"}\n                    </button>\n                  </div>\n\n                  <div className=\"pl-2 pr-2 rounded-lg bg-accent px-2 py-1 text-sm text-muted-foreground\">\n                    <button\n                      type=\"button\"\n                      className=\" text-gray-500 hover:text-gray-700 dark:text-gray-300 hover:dark:text-gray-100 font-semibold rounded-sm\"\n                      onClick={(e) => {\n                        e.stopPropagation();\n                        handleApproval(editorKey, false);\n                      }}\n                      disabled={approvalLoading}\n                    >\n                      {approvalLoading && approvalDirection === \"reject\" ? \"Rejecting...\" : \"Reject\"}\n                    </button>\n                  </div>\n                </>\n              )}\n            </>\n          ) : (\n            <>\n              <div className=\"rounded-lg bg-accent px-2 py-1 text-sm text-muted-foreground\">\n                {readOnly ? \"Read Only\" : saveStatus}\n              </div>\n              {!readOnly && !isPublicNote && (\n                <div className=\" pl-2 pr-2 rounded-lg bg-accent px-2 py-1 text-sm text-muted-foreground\">\n                  <button\n                    type=\"button\"\n                    className=\"text-gray-500 hover:text-gray-700 dark:text-gray-300 hover:dark:text-gray-100 font-semibold rounded-sm\"\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      setShowModal(true);\n                    }}\n                  >\n                    Share\n                  </button>\n                </div>\n              )}\n              {!readOnly && (\n                <div className=\" pl-2 pr-2 rounded-lg bg-accent px-2 py-1 text-sm text-muted-foreground\">\n                  <button\n                    disabled={publishStatus !== \"Publish\" || publishLoading}\n                    type=\"button\"\n                    className={`text-gray-500 hover:text-gray-700 dark:text-gray-300 hover:dark:text-gray-100 font-semibold rounded-sm ${\n                      publishStatus !== \"Publish\" || publishLoading ? \"cursor-not-allowed\" : \"cursor-pointer\"\n                    }`}\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      handlePublish(editorKey, setPublishStatus);\n                    }}\n                  >\n                    {publishLoading ? \"Publishing...\" : publishStatus}\n                  </button>\n                </div>\n              )}\n            </>\n          )}\n        </div>\n      </div>\n\n      <div className=\"gap-4 px-12 py-6 pb-0 pt-10 pl-16 bg-white text-gray-900 dark:bg-background dark:text-gray-100 flex items-center \">\n        <div className=\"h-28 pt-1 text-gray-500 dark:text-gray-400 flex items-center justify-center\">\n          {titleIcon === \"\" ? (\n            <FileText className=\"h-20 w-20 text-[4rem]\" />\n          ) : (\n            <div className=\"h-20 w-20 flex items-center justify-center text-[4rem] text-gray-500 dark:text-gray-400\">\n              {titleIcon}\n            </div>\n          )}\n        </div>\n        <p className=\"text-4xl font-semibold leading-tight tracking-tight break-words max-w-full\">{editorTitle}</p>\n      </div>\n\n      <div className=\"flex-1 w-full pt-2\">\n        <EditorRoot>\n          <EditorContent\n            key={`editor-${editorKey}`}\n            // contenteditable={!readOnly}\n            initialContent={initialContent}\n            extensions={extensions}\n            onCreate={({ editor }) => {\n              editorRef.current = editor;\n              editor.setEditable(!readOnly);\n            }}\n            className=\"w-full h-full bg-background p-4\"\n            editorProps={{\n              handleDOMEvents: {\n                keydown: (_view, event) => handleCommandNavigation(event),\n              },\n              handlePaste: (view, event) => handleImagePaste(view, event, uploadFn),\n              handleDrop: (view, event, _slice, moved) => handleImageDrop(view, event, moved, uploadFn),\n              attributes: {\n                class:\n                  \"prose prose-lg dark:prose-invert prose-headings:font-title font-default focus:outline-none max-w-full \",\n              },\n            }}\n            onUpdate={({ editor }) => {\n              if (!readOnly) {\n                debouncedUpdates(editor);\n                debouncedUpdatesOnline(editor);\n                setSaveStatus(\"Unsaved\");\n              }\n            }}\n            slotAfter={<ImageResizer />}\n          >\n            <EditorCommand className=\"z-50 h-auto max-h-[330px] overflow-y-auto rounded-md border border-muted bg-background px-1 py-2 shadow-md transition-all\">\n              <EditorCommandEmpty className=\"px-2 text-muted-foreground\">No results</EditorCommandEmpty>\n              <EditorCommandList>\n                {suggestionItems.map((item) => (\n                  <EditorCommandItem\n                    value={item.title}\n                    onCommand={(val) => item.command?.(val)}\n                    className=\"flex w-full items-center space-x-2 rounded-md px-2 py-1 text-left text-sm hover:bg-accent aria-selected:bg-accent\"\n                    key={item.title}\n                  >\n                    <div className=\"flex h-10 w-10 items-center justify-center rounded-md border border-muted bg-background\">\n                      {item.icon}\n                    </div>\n                    <div>\n                      <p className=\"font-medium\">{item.title}</p>\n                      <p className=\"text-xs text-muted-foreground\">{item.description}</p>\n                    </div>\n                  </EditorCommandItem>\n                ))}\n              </EditorCommandList>\n            </EditorCommand>\n\n            <GenerativeMenuSwitch open={openAI} onOpenChange={setOpenAI}>\n              <Separator orientation=\"vertical\" />\n              <NodeSelector open={openNode} onOpenChange={setOpenNode} />\n              <Separator orientation=\"vertical\" />\n              <LinkSelector open={openLink} onOpenChange={setOpenLink} />\n              <Separator orientation=\"vertical\" />\n              <MathSelector />\n              <Separator orientation=\"vertical\" />\n              <TextButtons />\n              <Separator orientation=\"vertical\" />\n              <ColorSelector open={openColor} onOpenChange={setOpenColor} />\n            </GenerativeMenuSwitch>\n          </EditorContent>\n        </EditorRoot>\n      </div>\n      {modal}\n\n      {/* Modal for share button */}\n      {showModal && (\n        <div className=\"fixed inset-0 bg-black/50 z-50 flex items-center justify-center\">\n          <div className=\"relative bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-xl w-full max-w-md space-y-4\">\n            {/* Header */}\n            <div className=\"flex justify-between items-center\">\n              <h2 className=\"text-xl font-semibold text-gray-800 dark:text-white\">Share Note</h2>\n              <button\n                type=\"button\"\n                onClick={() => {\n                  onShareComplete?.();\n                  setShowModal(false);\n                  setShareNoteId(null);\n                  setNewEmail(\"\");\n                  setInvites([]);\n                }}\n                className=\"text-gray-500 hover:text-gray-800 dark:text-gray-400 dark:hover:text-white text-lg font-bold\"\n                aria-label=\"Close\"\n              >\n                <X />\n              </button>\n            </div>\n\n            {/* Add email + permission row */}\n            <div className=\"relative w-full flex items-center gap-1\">\n              {/* Input with extra padding on right for select */}\n              <input\n                type=\"email\"\n                required\n                pattern=\"^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$\"\n                value={newEmail}\n                onChange={(e) => setNewEmail(e.target.value)}\n                placeholder=\"Enter email or username\"\n                className=\"flex-1 pl-2 h-10 pr-20 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-200 rounded-md\"\n              />\n\n              {/* Select absolutely inside input */}\n              <select\n                disabled\n                value={newPermission}\n                onChange={(e) => setNewPermission(e.target.value as \"read\" | \"write\")}\n                className=\"absolute right-[70px] h-8 top-1/2 -translate-y-1/2   border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-300 text-sm rounded-md\"\n              >\n                <option value=\"read\">Read</option>\n                <option value=\"write\">Write</option>\n              </select>\n\n              {/* Add Button */}\n              <button\n                type=\"button\"\n                onClick={() => {\n                  if (!newEmail.trim()) return;\n                  const email = newEmail.trim();\n                  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n\n                  if (!email) return;\n\n                  if (!emailRegex.test(email)) {\n                    alert(\"Please enter a valid email address.\");\n                    return;\n                  }\n                  setInvites([...invites, { email: newEmail.trim(), permission: newPermission }]);\n                  setNewEmail(\"\");\n                  setNewPermission(\"read\");\n                }}\n                className=\"h-10 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md\"\n              >\n                Add\n              </button>\n            </div>\n\n            {/* Shared With List */}\n            {invites.length > 0 && (\n              <div className=\"mt-4 space-y-2\">\n                <h3 className=\"text-md font-semibold text-gray-700 dark:text-gray-300\">Shared With</h3>\n\n                {/* Scrollable container for list */}\n                <div className=\"max-h-32 overflow-y-auto space-y-2 custom-scroll p-1\">\n                  {invites.map((invite, index) => (\n                    <div\n                      key={invite?.email}\n                      className=\"flex items-center bg-gray-100 dark:bg-gray-600 rounded-lg p-2 gap-2\"\n                    >\n                      {/* Scrollable Email Box */}\n                      <div className=\"flex-1 overflow-x-hidden whitespace-nowrap text-gray-900 dark:text-gray-200 font-medium text-sm custom-scroll px-1\">\n                        {invite.email}\n                      </div>\n\n                      {/* Permission label */}\n                      <span className=\"text-sm text-gray-500 dark:text-gray-400 px-2 shrink-0\">\n                        {invite.permission === \"write\" ? \"Read & Write\" : \"Read\"}\n                      </span>\n\n                      {/* Remove Button */}\n                      <button\n                        type=\"button\"\n                        onClick={() => {\n                          setInvites(invites.filter((_, i) => i !== index));\n                        }}\n                        className=\"shrink-0 pr-1\"\n                      >\n                        <Trash2 className=\"h-4 w-4-\" />\n                      </button>\n                    </div>\n                  ))}\n                </div>\n              </div>\n            )}\n\n            {/* General Access */}\n            {/* <div className=\"space-y-2\">\n                <label htmlFor=\"generalAccess\" className=\"block text-sm font-medium text-gray-700 dark:text-gray-300\">\n                  General Access\n                </label>\n                <select\n                  value={generalAccess}\n                  onChange={(e) => setGeneralAccess(e.target.value)}\n                  className=\"w-full p-2 rounded-md border dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-900 dark:text-white\"\n                >\n                  <option value=\"1\">Restricted</option>\n                  <option value=\"0\">Private</option>\n                  <option value=\"2\">Anyone with Link</option>\n                </select>\n              </div> */}\n\n            {/* Footer */}\n            <div className=\"flex justify-between items-center pt-2\">\n              <button\n                type=\"button\"\n                onClick={() => {\n                  const noteIdToShare = shareNoteId || editorKey;\n                  handleInvite(noteIdToShare, invites, generalAccess);\n                  setInvites([]);\n                  setShowModal(false);\n                  // onShareComplete?.();\n                }}\n                disabled={invites.length === 0}\n                className={`px-4 py-2 rounded-md font-semibold text-white \n                    ${invites.length === 0 ? \"bg-gray-600 cursor-not-allowed\" : \"bg-blue-600 hover:bg-blue-700\"}`}\n              >\n                Share\n              </button>\n              <button\n                type=\"button\"\n                className=\"text-sm text-blue-500\"\n                onClick={() => {\n                  const noteIdToShare = shareNoteId || editorKey;\n                  navigator.clipboard.writeText(`${process.env.DOMAIN}/notes/${noteIdToShare}`);\n                  setCopied(true);\n                  setTimeout(() => setCopied(false), 2000);\n                }}\n              >\n                {copied ? (\n                  <span className=\"text-blue-500 font-medium dark:text-blue-500\">Copied!</span>\n                ) : (\n                  <div className=\"flex p-1 items-center hover:underline\">\n                    <Paperclip className=\"h-4\" />\n                    <span>Copy link</span>\n                  </div>\n                )}\n              </button>\n            </div>\n          </div>\n        </div>\n      )}\n      {showHealthDialog && (\n        <HealthCheckDialog open={showHealthDialog} onOpenChange={setShowHealthDialog} onSubmit={addHealthCheck} />\n      )}\n    </div>\n  );\n};\n\nexport default TailwindAdvancedEditor;\n"
          }
        ]
      }
    ]
  },
  "online_content_time": "2025-06-24T13:22:40.362Z"
}