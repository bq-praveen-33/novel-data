{
  "online_content": {
    "type": "doc",
    "content": [
      {
        "type": "heading",
        "attrs": {
          "level": 1
        },
        "content": [
          {
            "type": "text",
            "text": "üìä Graph Algorithms in C++: A Beginner-Friendly Guide"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Graphs are fundamental data structures used to model pairwise relationships between objects. Common in computer science, graphs appear in social networks, maps, recommendation systems, and more."
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "In this article, we‚Äôll cover:"
          }
        ]
      },
      {
        "type": "bulletList",
        "attrs": {
          "tight": false
        },
        "content": [
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "What is a Graph?"
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "Types of Graphs"
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "Graph Representations in C++"
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "BFS (Breadth-First Search)"
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "DFS (Depth-First Search)"
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "Dijkstra‚Äôs Algorithm"
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "Topological Sort (Kahn‚Äôs Algorithm)"
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "horizontalRule"
      },
      {
        "type": "heading",
        "attrs": {
          "level": 2
        },
        "content": [
          {
            "type": "text",
            "text": "üîó What is a Graph?"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "A "
          },
          {
            "type": "text",
            "marks": [
              {
                "type": "bold"
              }
            ],
            "text": "Graph"
          },
          {
            "type": "text",
            "text": " consists of:"
          }
        ]
      },
      {
        "type": "bulletList",
        "attrs": {
          "tight": false
        },
        "content": [
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "marks": [
                      {
                        "type": "bold"
                      }
                    ],
                    "text": "Vertices (nodes)"
                  },
                  {
                    "type": "text",
                    "text": ": Represent entities."
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "marks": [
                      {
                        "type": "bold"
                      }
                    ],
                    "text": "Edges"
                  },
                  {
                    "type": "text",
                    "text": ": Represent relationships or connections."
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "attrs": {
          "level": 3
        },
        "content": [
          {
            "type": "text",
            "text": "Types of Graphs:"
          }
        ]
      },
      {
        "type": "bulletList",
        "attrs": {
          "tight": false
        },
        "content": [
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "marks": [
                      {
                        "type": "bold"
                      }
                    ],
                    "text": "Directed vs. Undirected"
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "marks": [
                      {
                        "type": "bold"
                      }
                    ],
                    "text": "Weighted vs. Unweighted"
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "marks": [
                      {
                        "type": "bold"
                      }
                    ],
                    "text": "Cyclic vs. Acyclic"
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "horizontalRule"
      },
      {
        "type": "heading",
        "attrs": {
          "level": 2
        },
        "content": [
          {
            "type": "text",
            "text": "üß± Graph Representation in C++"
          }
        ]
      },
      {
        "type": "heading",
        "attrs": {
          "level": 3
        },
        "content": [
          {
            "type": "text",
            "text": "1. "
          },
          {
            "type": "text",
            "marks": [
              {
                "type": "bold"
              }
            ],
            "text": "Adjacency List"
          }
        ]
      },
      {
        "type": "codeBlock",
        "attrs": {
          "language": null
        },
        "content": [
          {
            "type": "text",
            "text": "cpp"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "CopyEdit"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "code"
              }
            ],
            "text": "vector<int> adj[100]; // for 100 nodes adj[0].push_back(1); // edge from node 0 to 1 "
          }
        ]
      },
      {
        "type": "heading",
        "attrs": {
          "level": 3
        },
        "content": [
          {
            "type": "text",
            "text": "2. "
          },
          {
            "type": "text",
            "marks": [
              {
                "type": "bold"
              }
            ],
            "text": "Adjacency Matrix"
          }
        ]
      },
      {
        "type": "codeBlock",
        "attrs": {
          "language": null
        },
        "content": [
          {
            "type": "text",
            "text": "cpp"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "CopyEdit"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "code"
              }
            ],
            "text": "int adj[100][100] = {0}; // matrix of 0s adj[0][1] = 1; // edge from 0 to 1 "
          }
        ]
      },
      {
        "type": "horizontalRule"
      },
      {
        "type": "heading",
        "attrs": {
          "level": 2
        },
        "content": [
          {
            "type": "text",
            "text": "üîç BFS (Breadth-First Search)"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Uses a queue. Useful for finding shortest paths in unweighted graphs."
          }
        ]
      },
      {
        "type": "codeBlock",
        "attrs": {
          "language": null
        },
        "content": [
          {
            "type": "text",
            "text": "cpp"
          }
        ]
      },
      {
        "type": "codeBlock",
        "attrs": {
          "language": null
        },
        "content": [
          {
            "type": "text",
            "text": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvoid bfs(int start, vector<int> adj[], int n) {\n    vector<bool> visited(n, false);\n    queue<int> q;\n\n    visited[start] = true;\n    q.push(start);\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        cout << node << \" \";\n\n        for (int neighbor : adj[node]) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                q.push(neighbor);\n            }\n        }\n    }\n}\n"
          }
        ]
      },
      {
        "type": "horizontalRule"
      },
      {
        "type": "heading",
        "attrs": {
          "level": 2
        },
        "content": [
          {
            "type": "text",
            "text": "üß≠ DFS (Depth-First Search)"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Uses recursion or a stack. Useful for exploring components."
          }
        ]
      },
      {
        "type": "codeBlock",
        "attrs": {
          "language": null
        },
        "content": [
          {
            "type": "text",
            "text": "cpp"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "CopyEdit"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "code"
              }
            ],
            "text": "void dfs(int node, vector<int> adj[], vector<bool>& visited) {     visited[node] = true;     cout << node << \" \";      for (int neighbor : adj[node]) {         if (!visited[neighbor]) {             dfs(neighbor, adj, visited);         }     } } "
          }
        ]
      },
      {
        "type": "horizontalRule"
      },
      {
        "type": "heading",
        "attrs": {
          "level": 2
        },
        "content": [
          {
            "type": "text",
            "text": "üõ£Ô∏è Dijkstra's Algorithm"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Used to find shortest paths in "
          },
          {
            "type": "text",
            "marks": [
              {
                "type": "bold"
              }
            ],
            "text": "weighted"
          },
          {
            "type": "text",
            "text": " graphs with "
          },
          {
            "type": "text",
            "marks": [
              {
                "type": "bold"
              }
            ],
            "text": "non-negative"
          },
          {
            "type": "text",
            "text": " edges."
          }
        ]
      },
      {
        "type": "codeBlock",
        "attrs": {
          "language": null
        },
        "content": [
          {
            "type": "text",
            "text": "cpp"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "CopyEdit"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "code"
              }
            ],
            "text": "#include <iostream> #include <vector> #include <queue> using namespace std;  typedef pair<int, int> pii;  void dijkstra(int src, vector<pii> adj[], int n) {     vector<int> dist(n, 1e9);     priority_queue<pii, vector<pii>, greater<pii>> pq;      dist[src] = 0;     pq.push({0, src});      while (!pq.empty()) {         int u = pq.top().second;         int d_u = pq.top().first;         pq.pop();          for (auto [v, weight] : adj[u]) {             if (dist[v] > d_u + weight) {                 dist[v] = d_u + weight;                 pq.push({dist[v], v});             }         }     }      for (int i = 0; i < n; i++)         cout << \"Distance to \" << i << \": \" << dist[i] << endl; } "
          }
        ]
      },
      {
        "type": "horizontalRule"
      },
      {
        "type": "heading",
        "attrs": {
          "level": 2
        },
        "content": [
          {
            "type": "text",
            "text": "üèóÔ∏è Topological Sort (Kahn's Algorithm)"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Applicable to "
          },
          {
            "type": "text",
            "marks": [
              {
                "type": "bold"
              }
            ],
            "text": "DAGs"
          },
          {
            "type": "text",
            "text": " (Directed Acyclic Graphs)."
          }
        ]
      },
      {
        "type": "codeBlock",
        "attrs": {
          "language": null
        },
        "content": [
          {
            "type": "text",
            "text": "cpp"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "CopyEdit"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "code"
              }
            ],
            "text": "#include <iostream> #include <vector> #include <queue> using namespace std;  void topoSort(int n, vector<int> adj[]) {     vector<int> inDegree(n, 0);     for (int u = 0; u < n; u++)         for (int v : adj[u])             inDegree[v]++;      queue<int> q;     for (int i = 0; i < n; i++)         if (inDegree[i] == 0)             q.push(i);      while (!q.empty()) {         int u = q.front(); q.pop();         cout << u << \" \";          for (int v : adj[u]) {             inDegree[v]--;             if (inDegree[v] == 0)                 q.push(v);         }     } } "
          }
        ]
      },
      {
        "type": "horizontalRule"
      },
      {
        "type": "heading",
        "attrs": {
          "level": 2
        },
        "content": [
          {
            "type": "text",
            "text": "üß† Summary"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "AlgorithmUse CaseTime ComplexityBFSShortest path in unweighted graphsO(V + E)DFSComponent traversal, cycle detectionO(V + E)DijkstraShortest path in weighted graphsO((V + E) log V)Topological SortDAG orderingO(V + E)"
          }
        ]
      },
      {
        "type": "horizontalRule"
      },
      {
        "type": "heading",
        "attrs": {
          "level": 2
        }
      }
    ]
  },
  "online_content_time": "2025-06-11T11:31:40.202Z"
}