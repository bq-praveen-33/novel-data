{
  "online_content": {
    "type": "doc",
    "content": [
      {
        "type": "heading",
        "attrs": {
          "level": 1
        },
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "bold"
              }
            ],
            "text": "Building and scaling Notion’s data lake"
          }
        ]
      },
      {
        "type": "image",
        "attrs": {
          "src": "https://www.notion.com/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fspoqsaf9291f%2F66rsNrrnpIWvY1WJhDdLP6%2F5c10cce95943826515f8edb371810906%2Fcubes2_1.png&w=96&q=80",
          "alt": "",
          "title": null,
          "width": 48,
          "height": 48
        }
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "By XZ Tie, Nathan Louie, Thomas Chow, Darin Im, Abhishek Modi, Wendy Jiao"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "12 min read"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "textStyle",
                "attrs": {
                  "color": "rgba(0, 0, 0, 0.59)"
                }
              },
              {
                "type": "bold"
              }
            ],
            "text": "Share this post"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "In the past three years Notion’s data has expanded 10x due to user and content growth, with a doubling rate of 6-12 months. Managing this rapid growth while meeting the ever-increasing data demands of critical product and analytics use cases, especially our recent Notion AI features, meant building and scaling Notion’s data lake. Here’s how we did it. "
          }
        ]
      },
      {
        "type": "heading",
        "attrs": {
          "level": 2
        },
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "textStyle",
                "attrs": {
                  "color": ""
                }
              },
              {
                "type": "bold"
              }
            ],
            "text": "Notion’s data model and growth"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Everything you see in Notion—texts, images, headings, lists, database rows, pages, etc—despite differing front-end representations and behaviors, is modeled as a \"block\" entity in the back end and stored in the Postgres database with a consistent structure, schema, and associated metadata (learn more about "
          },
          {
            "type": "text",
            "marks": [
              {
                "type": "link",
                "attrs": {
                  "href": "https://www.notion.so/blog/data-model-behind-notion",
                  "target": "_self",
                  "rel": "nofollow",
                  "class": "InlineTextLink_inlineLink__oN8YM InlineTextLink_colorInherit__oGlTG"
                }
              },
              {
                "type": "textStyle",
                "attrs": {
                  "color": ""
                }
              },
              {
                "type": "underline"
              }
            ],
            "text": "Notion's data model"
          },
          {
            "type": "text",
            "text": ")."
          }
        ]
      },
      {
        "type": "image",
        "attrs": {
          "src": "https://www.notion.com/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fspoqsaf9291f%2F4rrziPDb4W1MWIJd9DU75F%2Fea42dabcf0bd96470958a47e4f80c1d2%2FData_Lake_0.png&w=3840&q=75",
          "alt": "Data Lake initial image",
          "title": null,
          "width": 1488,
          "height": 582
        }
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Everything in Notion is a block, and these blocks are made up of data. Lots and lots of data."
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "All this block data has been doubling every 6 to 12 months, driven by user activity and content creation. At the start of 2021 we had more than 20 billion block rows in Postgres, and this figure has since grown to more than two hundred billion blocks—a data volume of hundreds of terabytes, even when compressed."
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "To manage this data growth while enhancing the user experience, we’ve strategically expanded our database infrastructure from one Postgres instance to a more complex sharded architecture. We began in 2021 by "
          },
          {
            "type": "text",
            "marks": [
              {
                "type": "link",
                "attrs": {
                  "href": "https://www.notion.so/blog/sharding-postgres-at-notion",
                  "target": "_self",
                  "rel": "nofollow",
                  "class": "InlineTextLink_inlineLink__oN8YM InlineTextLink_colorInherit__oGlTG"
                }
              },
              {
                "type": "textStyle",
                "attrs": {
                  "color": ""
                }
              },
              {
                "type": "underline"
              }
            ],
            "text": "horizontally sharding our Postgres database into 32 physical instances, each comprising 15 logical shards"
          },
          {
            "type": "text",
            "text": ", and continued in 2023 by "
          },
          {
            "type": "text",
            "marks": [
              {
                "type": "link",
                "attrs": {
                  "href": "https://www.notion.so/blog/the-great-re-shard",
                  "target": "_self",
                  "rel": "nofollow",
                  "class": "InlineTextLink_inlineLink__oN8YM InlineTextLink_colorInherit__oGlTG"
                }
              },
              {
                "type": "textStyle",
                "attrs": {
                  "color": ""
                }
              },
              {
                "type": "underline"
              }
            ],
            "text": "increasing the number of physical instances to 96, with five logical shards per instance"
          },
          {
            "type": "text",
            "text": ". Thus we maintained a total of 480 logical shards while ensuring long-term scalable data management and retrieval capabilities."
          }
        ]
      },
      {
        "type": "image",
        "attrs": {
          "src": "https://www.notion.com/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fspoqsaf9291f%2F64NhJVfqvEKp5e5n8efop3%2F338db6104a05a5bfc8a8eadc4fca73ec%2FData_Lake_1.png&w=3840&q=75",
          "alt": "Data lake image 1",
          "title": null,
          "width": 2374,
          "height": 1018
        }
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "By 2021 Postgres comprised the core of our production infrastructure, handling everything from online user traffic to various offline data analytics and machine learning needs. As the demands on both online and offline data increased, we realized it was essential to build a dedicated data infrastructure to handle offline data without interfering with online traffic."
          }
        ]
      },
      {
        "type": "heading",
        "attrs": {
          "level": 2
        },
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "textStyle",
                "attrs": {
                  "color": ""
                }
              },
              {
                "type": "bold"
              }
            ],
            "text": "Notion’s data warehouse architecture in 2021"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "In 2021, we initiated this dedicated data infrastructure with a simple ELT (Extract, Load, and Transform) pipeline that used the third-party tool Fivetran to ingest data from the Postgres WAL (Write Ahead Log) to Snowflake and set up 480 hourly-run connectors for the 480 shards to write to the same number of raw Snowflake tables. We then merged these tables into a single large table for analytics, reporting, and machine learning use cases."
          }
        ]
      },
      {
        "type": "image",
        "attrs": {
          "src": "https://www.notion.com/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fspoqsaf9291f%2F4eEtecJis4Q6Pb3PjC9yzf%2F3eeb2c4c820328192cde31262ec6ff99%2FData_Lake_2.png&w=3840&q=75",
          "alt": "Data lake image 2",
          "title": null,
          "width": 1728,
          "height": 1040
        }
      },
      {
        "type": "heading",
        "attrs": {
          "level": 3
        },
        "content": [
          {
            "type": "hardBreak",
            "marks": [
              {
                "type": "bold"
              }
            ]
          },
          {
            "type": "text",
            "marks": [
              {
                "type": "bold"
              }
            ],
            "text": "Scaling challenges"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "As our Postgres data grew, we encountered several scaling challenges."
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "bold"
              }
            ],
            "text": "Operability"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "The overhead of monitoring and managing 480 Fivetran connectors, along with re-syncing them during Postgres re-sharding, upgrade, and maintenance periods, became extremely high, creating a significant on-call burden for team members."
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "bold"
              }
            ],
            "text": "Speed, data freshness and cost"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Ingesting data to Snowflake became slower and more costly, primarily due to Notion's unique update-heavy workload. Notion users update existing blocks (texts, headings, titles, bullet lists, database rows, etc) much more often than they add new ones. This causes block data to be predominantly update-heavy—90% of Notion upserts are updates. Most data warehouses, including Snowflake, are optimized for insert-heavy workloads, which makes it increasingly challenging for them to ingest block data."
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "bold"
              }
            ],
            "text": "Use case support"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Data transformation logic became more complex and heavy, surpassing the capabilities of the standard SQL interface offered by off-the-shelf data warehouses."
          }
        ]
      },
      {
        "type": "bulletList",
        "attrs": {
          "tight": false
        },
        "content": [
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "One important use case is constructing denormalized views of Notion’s block data for key products (e.g., AI and Search). Permission data, for example, ensures that only the right people can read or change a block ("
                  },
                  {
                    "type": "text",
                    "marks": [
                      {
                        "type": "link",
                        "attrs": {
                          "href": "https://www.notion.so/blog/data-model-behind-notion",
                          "target": "_self",
                          "rel": "nofollow",
                          "class": "InlineTextLink_inlineLink__oN8YM InlineTextLink_colorInherit__oGlTG"
                        }
                      },
                      {
                        "type": "textStyle",
                        "attrs": {
                          "color": ""
                        }
                      },
                      {
                        "type": "underline"
                      }
                    ],
                    "text": "this blog"
                  },
                  {
                    "type": "text",
                    "text": " discusses Notion’s block permission model). But a block’s permission isn’t statically stored in the associated Postgres—it has to be constructed on the fly via expensive tree traversal computation."
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "In the following example, "
                  },
                  {
                    "type": "text",
                    "marks": [
                      {
                        "type": "code"
                      }
                    ],
                    "text": "block_1"
                  },
                  {
                    "type": "text",
                    "text": ", "
                  },
                  {
                    "type": "text",
                    "marks": [
                      {
                        "type": "code"
                      }
                    ],
                    "text": "block_2"
                  },
                  {
                    "type": "text",
                    "text": ", and "
                  },
                  {
                    "type": "text",
                    "marks": [
                      {
                        "type": "code"
                      }
                    ],
                    "text": "block_3 "
                  },
                  {
                    "type": "text",
                    "text": "inherit permissions from their immediate parents ("
                  },
                  {
                    "type": "text",
                    "marks": [
                      {
                        "type": "code"
                      }
                    ],
                    "text": "page_3 "
                  },
                  {
                    "type": "text",
                    "text": "and "
                  },
                  {
                    "type": "text",
                    "marks": [
                      {
                        "type": "code"
                      }
                    ],
                    "text": "page_2"
                  },
                  {
                    "type": "text",
                    "text": ") and ancestors ("
                  },
                  {
                    "type": "text",
                    "marks": [
                      {
                        "type": "code"
                      }
                    ],
                    "text": "page_1 "
                  },
                  {
                    "type": "text",
                    "text": "and "
                  },
                  {
                    "type": "text",
                    "marks": [
                      {
                        "type": "code"
                      }
                    ],
                    "text": "workspace_a). "
                  },
                  {
                    "type": "text",
                    "text": "To build permission data for each of these blocks, we must traverse its ancestor tree all the way up to the root ("
                  },
                  {
                    "type": "text",
                    "marks": [
                      {
                        "type": "code"
                      }
                    ],
                    "text": "workspace_a"
                  },
                  {
                    "type": "text",
                    "text": ") in order to ensure completeness. With hundreds of billions of blocks whose ancestor depths ranged from a few to dozens, this kind of compute was very costly and would simply time out in Snowflake."
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "image",
        "attrs": {
          "src": "https://www.notion.com/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fspoqsaf9291f%2FMydQ7FIKshSG7yHcqUBBh%2F730a7be57bebd5670132b0aa404cfbc2%2FData_Lake_3.png&w=3840&q=75",
          "alt": "Data lake image 3",
          "title": null,
          "width": 1658,
          "height": 626
        }
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Constructing permission data for each block requires traversing the entire ancestor tree."
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Because of these challenges, we started to explore building our data lake."
          }
        ]
      },
      {
        "type": "heading",
        "attrs": {
          "level": 2
        },
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "textStyle",
                "attrs": {
                  "color": ""
                }
              },
              {
                "type": "bold"
              }
            ],
            "text": "Building and scaling Notion’s in-house data lake"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Here were our objectives for building an in-house data lake:"
          }
        ]
      },
      {
        "type": "bulletList",
        "attrs": {
          "tight": false
        },
        "content": [
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "Establish a data repository capable of storing both raw and processed data at scale."
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "Enable fast, scalable, operable, and cost-efficient data ingestion and computation for any workload—especially Notion's update-heavy block data."
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "Unlock AI, Search, and other product use cases that require denormalized data."
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "However, while our data lake is a big step forward, it's important to clarify what it's not intended to do:"
          }
        ]
      },
      {
        "type": "bulletList",
        "attrs": {
          "tight": false
        },
        "content": [
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "Completely replace Snowflake. We’ll continue to benefit from Snowflake’s operational and ecosystem ease by using it for most other workloads, particularly those that are insert-heavy and don’t require large-scale denormalized tree traversal."
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "Completely replace Fivetran. We’ll continue taking advantage of Fivetran’s effectiveness with non-update heavy tables, small dataset ingestion, and diverse third-party data sources and destinations."
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "Support online use cases that require second-level or stricter latency. The Notion data lake will primarily focus on offline workloads that can tolerate minutes to hours of latency."
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "attrs": {
          "level": 3
        },
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "bold"
              }
            ],
            "text": "Our data lake’s high-level design"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Since 2022 we’ve used the in-house data lake architecture shown below. We ingest incrementally updated data from Postgres to Kafka using Debezium CDC connectors, then use "
          },
          {
            "type": "text",
            "marks": [
              {
                "type": "link",
                "attrs": {
                  "href": "https://hudi.apache.org/",
                  "target": "_self",
                  "rel": "nofollow",
                  "class": "InlineTextLink_inlineLink__oN8YM InlineTextLink_colorInherit__oGlTG"
                }
              },
              {
                "type": "textStyle",
                "attrs": {
                  "color": ""
                }
              },
              {
                "type": "underline"
              }
            ],
            "text": "Apache Hudi"
          },
          {
            "type": "text",
            "text": ", an open-source data processing and storage framework, to write these updates from Kafka to S3. With this raw data we can then do transformation, denormalization (e.g., tree traversal and permission data construction for each block), and enrichment, then store the processed data in S3 again or in downstream systems to serve analytics and reporting needs, as well as AI, Search, and other product requirements."
          }
        ]
      },
      {
        "type": "image",
        "attrs": {
          "src": "https://www.notion.com/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fspoqsaf9291f%2F47gLr3QRSWQ9MpPbvE54Nf%2F2d232b1d4a0ea226f07852d6d824b490%2FData_Lake_4.png&w=3840&q=75",
          "alt": "Data lake image 4",
          "title": null,
          "width": 2274,
          "height": 660
        }
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Notion’s in-house data lake is built on Debezium CDC connector, Kafka, Hudi, Spark, and S3."
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Next we’ll describe and illustrate the design principles and decisions we arrived at after extensive research, discussion, and prototyping work."
          }
        ]
      },
      {
        "type": "heading",
        "attrs": {
          "level": 3
        },
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "bold"
              }
            ],
            "text": "Design decision 1: Choosing a data repository and lake"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Our first decision was to use S3 as a data repository and lake to store all raw and processed data, and position data warehouse and other product-facing data stores such as ElasticSearch, Vector Database, Key-Value store, etc as its downstream. We made this decision for two reasons:"
          }
        ]
      },
      {
        "type": "bulletList",
        "attrs": {
          "tight": false
        },
        "content": [
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "It aligned with Notion’s AWS tech stack, e.g., our Postgres database is based on AWS RDS and its export-to-S3 feature (described in later sections) allows us to easily bootstrap tables in S3."
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "S3 has proven its ability to store large amounts of data and support various data processing engines (like Spark) at low cost."
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "By offloading heavy ingestion and compute workloads to S3 and only ingesting highly cleaned and business-critical data to Snowflake and product-facing data stores, we significantly improved data compute scalability and speed and reduced cost."
          }
        ]
      },
      {
        "type": "heading",
        "attrs": {
          "level": 3
        },
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "bold"
              }
            ],
            "text": "Design decision 2: Choosing our processing engine"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "We chose Spark as our main data processing engine because as an open-source framework, it could be rapidly set up and evaluated to verify that it met our data transformation needs. Spark has four key benefits:"
          }
        ]
      },
      {
        "type": "bulletList",
        "attrs": {
          "tight": false
        },
        "content": [
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "Spark’s wide range of built-in functions and UDFs (User Defined Functions) beyond SQL enable complex data processing logics like tree traversal and block data denormalization, as described above."
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "It offers a user-friendly PySpark framework for most lighter use cases, and advanced Scala Spark for high-performance, heavy data processing."
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "It processes large-scale data (e.g., billions of blocks and hundreds of terabytes) in a distributed manner, and exposes extensive configurations, which allows us to fine-tune our control over partitioning, data skewness, and resource allocation. It also enables us to break down complex jobs into smaller tasks and optimize resourcing for each task, which helps us achieve reasonable runtime without over-provisioning or wasting resources."
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "Finally, Spark’s open-source nature offers cost-efficiency benefits."
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "attrs": {
          "level": 3
        },
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "bold"
              }
            ],
            "text": "Design decision 3: Preference for incremental ingestion over snapshot dump"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "After finalizing our data lake storage and processing engine, we explored solutions for ingesting Postgres data to S3. We wound up considering two approaches: incremental ingestion of changed data and periodic full snapshots of Postgres tables. In the end, based on performance and cost comparisons, we opted for a hybrid design:"
          }
        ]
      },
      {
        "type": "bulletList",
        "attrs": {
          "tight": false
        },
        "content": [
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "marks": [
                      {
                        "type": "bold"
                      }
                    ],
                    "text": "During normal operations, incrementally ingest and continuously apply changed Postgres data to S3."
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "marks": [
                      {
                        "type": "bold"
                      }
                    ],
                    "text": "In rare cases, take a full Postgres snapshot once to bootstrap tables in S3."
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "The incremental approach ensures fresher data at lower cost and with minimal delay (a few minutes to a couple hours, depending on table size). Taking a full snapshot and dumping to S3, by contrast, takes more than 10 hours and costs twice as much, so we do so infrequently, when bootstraping new tables in S3."
          }
        ]
      },
      {
        "type": "heading",
        "attrs": {
          "level": 3
        },
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "bold"
              }
            ],
            "text": "Design decision 4: Streamlining incremental ingestion"
          }
        ]
      },
      {
        "type": "bulletList",
        "attrs": {
          "tight": false
        },
        "content": [
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "marks": [
                      {
                        "type": "bold"
                      }
                    ],
                    "text": "Kafka CDC Connector for Postgres → to → Kafka"
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "We chose the Kafka Debezium CDC (Change Data Capture) connector to publish incrementally changed Postgres data to Kafka, similar to Fivetran’s data ingestion method. We chose it together with Kafka for their scalability, ease of setup, and close integration with our existing infrastructure."
          }
        ]
      },
      {
        "type": "bulletList",
        "attrs": {
          "tight": false
        },
        "content": [
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "marks": [
                      {
                        "type": "bold"
                      }
                    ],
                    "text": "Hudi for Kafka → to → S3"
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "To ingest the incremental data from Kafka to S3, we considered three excellent data lake and ingestion solutions: "
          },
          {
            "type": "text",
            "marks": [
              {
                "type": "link",
                "attrs": {
                  "href": "https://hudi.apache.org/",
                  "target": "_self",
                  "rel": "nofollow",
                  "class": "InlineTextLink_inlineLink__oN8YM InlineTextLink_colorInherit__oGlTG"
                }
              },
              {
                "type": "textStyle",
                "attrs": {
                  "color": ""
                }
              },
              {
                "type": "underline"
              }
            ],
            "text": "Apache Hudi"
          },
          {
            "type": "text",
            "text": ", "
          },
          {
            "type": "text",
            "marks": [
              {
                "type": "link",
                "attrs": {
                  "href": "https://iceberg.apache.org/",
                  "target": "_self",
                  "rel": "nofollow",
                  "class": "InlineTextLink_inlineLink__oN8YM InlineTextLink_colorInherit__oGlTG"
                }
              },
              {
                "type": "textStyle",
                "attrs": {
                  "color": ""
                }
              },
              {
                "type": "underline"
              }
            ],
            "text": "Apache Iceberg"
          },
          {
            "type": "text",
            "text": ", and "
          },
          {
            "type": "text",
            "marks": [
              {
                "type": "link",
                "attrs": {
                  "href": "https://delta.io/",
                  "target": "_self",
                  "rel": "nofollow",
                  "class": "InlineTextLink_inlineLink__oN8YM InlineTextLink_colorInherit__oGlTG"
                }
              },
              {
                "type": "textStyle",
                "attrs": {
                  "color": ""
                }
              },
              {
                "type": "underline"
              }
            ],
            "text": "DataBricks Delta Lake"
          },
          {
            "type": "text",
            "text": ". In the end we chose Hudi for its excellent performance with our update-heavy workload and its open-source nature and native "
          },
          {
            "type": "text",
            "marks": [
              {
                "type": "link",
                "attrs": {
                  "href": "https://cwiki.apache.org/confluence/display/HUDI/RFC+-+39+Deltastreamer+source+for+debezium+CDC+logs",
                  "target": "_self",
                  "rel": "nofollow",
                  "class": "InlineTextLink_inlineLink__oN8YM InlineTextLink_colorInherit__oGlTG"
                }
              },
              {
                "type": "textStyle",
                "attrs": {
                  "color": ""
                }
              },
              {
                "type": "underline"
              }
            ],
            "text": "integration with Debezium CDC messages"
          },
          {
            "type": "text",
            "text": "."
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Iceberg and Delta Lake, on the other hand, weren’t optimized for our update-heavy workload when we considered them in 2022. Iceberg also lacked an out-of-box solution that understands Debezium messages; Delta Lake does have one, but it isn’t open source. We would have had to implement our own Debezium consumer if we’d gone with either of those solutions."
          }
        ]
      },
      {
        "type": "heading",
        "attrs": {
          "level": 3
        },
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "bold"
              }
            ],
            "text": "Design decision 5: Ingest raw data before processing"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Finally, we decided to ingest raw Postgres data to S3 without on-the-fly processing in order to establish a single source of truth and simplify debugging across the entire data pipeline. Once raw data is in S3, we then do transformation, denormalization, enrichment, and other types of data processing. We store intermediate data in S3 again and only ingest highly cleaned, structured, and business-critical data to downstream systems for analytics, reporting, and product needs."
          }
        ]
      },
      {
        "type": "heading",
        "attrs": {
          "level": 2
        },
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "textStyle",
                "attrs": {
                  "color": ""
                }
              },
              {
                "type": "bold"
              }
            ],
            "text": "Scaling and operating our data lake"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "We experimented with many detailed setups in order to tackle the scalability challenges associated with Notion’s ever-increasing data volume. Here's what we tried and how it went:"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "bold"
              }
            ],
            "text": "1. CDC connector and Kafka setup"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "We set up one Debezium CDC connector per Postgres host and deploy them in an AWS EKS cluster. Because of the maturity of Debezium and EKS management and Kafka's scalability, we’ve only had to upgrade the EKS and Kafka clusters a few times in the past two years. As of May 2024, it smoothly handles tens of MB/sec of Postgres row changes."
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "We also configure one Kafka topic per Postgres table and let all connectors consuming from 480 shards write to the same topic for that table. This setup significantly reduced the complexity of maintaining 480 topics for each table and simplified downstream Hudi ingestion to S3, significantly reducing operational overhead."
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "bold"
              }
            ],
            "text": "2. Hudi setup"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "We used "
          },
          {
            "type": "text",
            "marks": [
              {
                "type": "link",
                "attrs": {
                  "href": "https://hudi.apache.org/docs/0.10.0/hoodie_deltastreamer/",
                  "target": "_self",
                  "rel": "nofollow",
                  "class": "InlineTextLink_inlineLink__oN8YM InlineTextLink_colorInherit__oGlTG"
                }
              },
              {
                "type": "textStyle",
                "attrs": {
                  "color": ""
                }
              },
              {
                "type": "underline"
              }
            ],
            "text": "Apache Hudi Deltastreamer"
          },
          {
            "type": "text",
            "text": ", a Spark-based ingestion job, to consume Kafka messages and replicate the state of Postgres table in S3. After several rounds of performance tuning, we established a fast, scalable ingestion setup to ensure data freshness. This setup provides a delay of just a few minutes for most tables, and up to two hours for the largest one, the block table (see graphic below)."
          }
        ]
      },
      {
        "type": "bulletList",
        "attrs": {
          "tight": false
        },
        "content": [
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "We use the default COPY_ON_WRITE Hudi table type with UPSERT operation, which suits our update-heavy workload."
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "To manage data more effectively and minimize write amplification (i.e., the number of files updated per batched ingestion run), we fine-tuned three configurations:"
                  }
                ]
              },
              {
                "type": "bulletList",
                "attrs": {
                  "tight": false
                },
                "content": [
                  {
                    "type": "listItem",
                    "content": [
                      {
                        "type": "paragraph",
                        "content": [
                          {
                            "type": "text",
                            "text": "Partition/shard data using the same Postgres shard scheme, i.e., the "
                          },
                          {
                            "type": "text",
                            "marks": [
                              {
                                "type": "code"
                              }
                            ],
                            "text": "hoodie.datasource.write.partitionpath.field: db_schema_source_partition"
                          },
                          {
                            "type": "text",
                            "text": " config. This partitions the S3 dataset into 480 shards, from "
                          },
                          {
                            "type": "text",
                            "marks": [
                              {
                                "type": "code"
                              }
                            ],
                            "text": "shard0001 "
                          },
                          {
                            "type": "text",
                            "text": "to "
                          },
                          {
                            "type": "text",
                            "marks": [
                              {
                                "type": "code"
                              }
                            ],
                            "text": "shard0480,"
                          },
                          {
                            "type": "text",
                            "text": " making it more likely that a batch of incoming updates map to the same set of files from the same shard."
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "type": "listItem",
                    "content": [
                      {
                        "type": "paragraph",
                        "content": [
                          {
                            "type": "text",
                            "text": "Sort data based on the last updated time (event_lsn), i.e., the "
                          },
                          {
                            "type": "text",
                            "marks": [
                              {
                                "type": "code"
                              }
                            ],
                            "text": "source-ordering-field: event_lsn"
                          },
                          {
                            "type": "text",
                            "text": " config. This is based on our observation that more recent blocks are more likely to get updated, which allows us to prune files with only outdated blocks."
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "type": "listItem",
                    "content": [
                      {
                        "type": "paragraph",
                        "content": [
                          {
                            "type": "text",
                            "text": "Set the index type to be bloom filter, i.e., the "
                          },
                          {
                            "type": "text",
                            "marks": [
                              {
                                "type": "code"
                              }
                            ],
                            "text": "hoodie.index.type: BLOOM"
                          }
                        ]
                      },
                      {
                        "type": "paragraph",
                        "content": [
                          {
                            "type": "text",
                            "text": "config, to further optimize the workload."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "image",
        "attrs": {
          "src": "https://www.notion.com/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fspoqsaf9291f%2F2lSK1kBy9dHNg9UF5HU4gs%2F72ddf2a3cf506ccaed49ce75af8d536f%2FData_Lake_5.png&w=3840&q=75",
          "alt": "Data lake image 5",
          "title": null,
          "width": 2328,
          "height": 1402
        }
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Hudi Deltastreamer setup for the block table."
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "bold"
              }
            ],
            "text": "3. Spark data processing setup"
          },
          {
            "type": "hardBreak",
            "marks": [
              {
                "type": "bold"
              }
            ]
          },
          {
            "type": "hardBreak",
            "marks": [
              {
                "type": "bold"
              }
            ]
          },
          {
            "type": "text",
            "text": "For the majority of our data processing jobs we utilize PySpark, whose relatively low learning curve makes it accessible to many team members. For more complex jobs such as tree traversal and denormalization, we leverage Spark’s superior performance in several key areas:"
          }
        ]
      },
      {
        "type": "bulletList",
        "attrs": {
          "tight": false
        },
        "content": [
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "We benefit from the performance efficiency of the Scala Spark."
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "We manage data more effectively by handling large and small shards separately (remember we kept the same 480 shards scheme in S3 to be consistent with Postgres); small shards have their entire data loaded into the Spark task container memory for fast processing, whereas large shards that exceed memory capacity are managed through disk reshuffling."
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "We utilize multi-threading and parallel processing to speed up processing of 480 shards, allowing us to optimize runtime and efficiency."
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "bold"
              }
            ],
            "text": "4. Bootstrap setup"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Here's how we bootstrap new tables:"
          }
        ]
      },
      {
        "type": "bulletList",
        "attrs": {
          "tight": false
        },
        "content": [
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "We first set up Debezium Connector to ingest Postgres changes to Kafka."
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "Starting from timestamp "
                  },
                  {
                    "type": "text",
                    "marks": [
                      {
                        "type": "code"
                      }
                    ],
                    "text": "t"
                  },
                  {
                    "type": "text",
                    "text": ", we kick off a AWS RDS-provided export-to-S3 job to save the latest snapshot of Postgres tables to S3. We then create a Spark job to read those data from S3 and write them to the Hudi table format."
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "Finally, we ensure that all changes made during the snapshotting process are captured by setting up Deltastreamer to read from Kafka messages from "
                  },
                  {
                    "type": "text",
                    "marks": [
                      {
                        "type": "code"
                      }
                    ],
                    "text": "t"
                  },
                  {
                    "type": "text",
                    "text": ". This step is crucial for maintaining data completeness and integrity."
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Thanks to the scalability of Spark and Hudi, these three steps usually complete within 24 hours, allowing us to perform re-bootstrap with manageable time to accommodate new table asks and Postgres upgrade and re-sharding operations."
          }
        ]
      },
      {
        "type": "heading",
        "attrs": {
          "level": 2
        },
        "content": [
          {
            "type": "text",
            "marks": [
              {
                "type": "textStyle",
                "attrs": {
                  "color": ""
                }
              },
              {
                "type": "bold"
              }
            ],
            "text": "The payoff: less money, more time, stronger infrastructure for AI"
          }
        ]
      },
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "We started developing our data lake infrastructure in the spring of 2022 and completed it by that fall. Due to the infra's inherently scalable nature, we were able to continually optimize and expand the Debezium EKS clusters, Kafka clusters, Deltastreamer, and Spark job to keep up with Notion's 6-to-12 month data doubling rate without significant overhauls. The payoff was significant:"
          }
        ]
      },
      {
        "type": "bulletList",
        "attrs": {
          "tight": false
        },
        "content": [
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "Moving several large, crucial Postgres datasets (some of them tens of TB large) to data lake gave us a net savings of over a million dollars for 2022 and proportionally higher savings in 2023 and 2024."
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "For these datasets, the end-to-end ingestion time from Postgres to S3 and Snowflake decreased from more than a day to a few minutes for small tables and up to a couple of hours for large ones. Re-syncs, when necessary, can be completed within 24 hours without overloading live databases."
                  }
                ]
              }
            ]
          },
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "type": "text",
                    "text": "Most importantly, the changeover unlocked massive data storage, compute, and freshness savings from a variety of analytics and product asks, enabling the successful rollout of Notion AI features in 2023 and 2024. Stay tuned for a detailed post on our Search and AI Embedding RAG Infra built on top of the data lake!"
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  "online_content_time": "2025-08-12T07:49:36.370Z"
}